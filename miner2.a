;
; MINER2.a ($4c00)
;
; Execution starts at 'miner2EntryPoint'

!src "constants.a"


animateLevel19EnergyFields  = $7e80

* = $4c00

!pseudopc $0d00 {
    ; $0d00
    ; plenty of zeros
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

    ; $0d40
footSprite
    ; the foot graphic
    !byte $33, $22, $33, $22, $33, $00, $00, $11, $55, $aa, $55, $aa, $ff, $99, $99, $ff
    !byte $44, $cc, $44, $cc, $cc, $00, $00, $88, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $11, $11, $22, $22, $55, $44, $44, $ff, $00, $11, $22, $00, $99, $44, $44, $ff
    !byte $88, $88, $44, $bb, $22, $44, $00, $ff, $00, $00, $00, $88, $44, $22, $22, $ff

    ; $0d80
guardianPositions
    ; plenty more zeros
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
guardianPositionsCopy
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

    ; $0dc0
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
}

!pseudopc $0f00 {
    !xor $55 {
; ***************************************************************************************
;
; plot
;
;   e.g. used to plot the player, and the leg/foot, vertical guardians
;
; On Entry:
;       ($77,$78) = source sprite address
;
;       A = mode:
;           Mode            Operation                                   Description
;           2               0                                           erase
;           3               source AND mask                             colour mask applied to source
;           4               if (screen not 255) then (source AND mask)  preserve solid colour 3
;           5               if (screen not 255) then 0                  zero except solid colour 3
;           10              (source AND $F0) EOR screen                 tint source to colour 2, eor with screen
;           anything else   source (AND mask) OR screen                 additive with mask
;
;       X = x pixel coordinate
;       Y = y pixel coordinate
;
; ***************************************************************************************
plot
    sta plotMode                        ;
    stx plotX                           ;
    sty plotY                           ;

    txa                                 ;
    and #3                              ;
    sta plotXOffset                     ; plotXOffset = offset within byte of X coordinate

    tya                                 ;
    and #7                              ;
    sta plotYOffset                     ; plotYOffset = offset within 8 byte cell of Y coordinate

    txa                                 ;
    and #$fc                            ;
    clc                                 ;
    ror                                 ;
    sta plotX                           ; plotX = (X pixel / 4) * 2
    tya                                 ;
    and #$f8                            ;
    clc                                 ;
    ror                                 ;
    ror                                 ;
    ror                                 ;
    sta plotY                           ; plotY = (Y pixel / 8)     [can be improved]

    lda plotMode                        ;
    cmp #10                             ;
    beq setMode10Address                ;
    cmp #2                              ;
    beq setMode2Address                 ;
    cmp #3                              ;
    beq setMode3Address                 ;
    cmp #4                              ;
    beq setMode4Address                 ;
    cmp #5                              ;
    beq setMode5Address                 ;

    lda #<getSpriteDefaultModeByte      ;
    sta getSourceByte + 1               ;
    lda #>getSpriteDefaultModeByte      ; set address getSpriteDefaultModeByte
    sta getSourceByte + 2               ;
    jmp calculateScreenAddrAndPlot      ;

setMode10Address
    lda #<getSpriteMode10Byte           ;
    sta getSourceByte + 1               ;
    lda #>getSpriteMode10Byte           ; set address getSpriteMode10Byte
    sta getSourceByte + 2               ;
    jmp calculateScreenAddrAndPlot      ;

setMode3Address
    lda #<getSpriteMode3Byte            ;
    sta getSourceByte + 1               ;
    lda #>getSpriteMode3Byte            ; address getSpriteMode3Byte
    sta getSourceByte + 2               ;
    jmp calculateScreenAddrAndPlot      ;

setMode4Address
    lda #<getSpriteMode4Byte            ;
    sta getSourceByte + 1               ;
    lda #>getSpriteMode4Byte            ; address getSpriteMode4Byte
    sta getSourceByte + 2               ;
    jmp calculateScreenAddrAndPlot      ;

setMode5Address
    lda #<getSpriteMode5Byte            ;
    sta getSourceByte + 1               ;
    lda #>getSpriteMode5Byte            ; address getSpriteMode5Byte
    sta getSourceByte + 2               ;
    jmp calculateScreenAddrAndPlot      ;

setMode2Address
    lda #<getSpriteMode2Byte            ;
    sta getSourceByte + 1               ;
    lda #>getSpriteMode2Byte            ; address getSpriteMode2Byte
    sta getSourceByte + 2               ;

; ***************************************************************************************
calculateScreenAddrAndPlot
    lda #<logicalScreenStart            ; }
    sta plotScreenAddressLow            ; }
    lda #>logicalScreenStart            ; } start at logical screen address
    sta plotScreenAddressHigh           ; }

    lda #0                              ;
    sta spriteRowCounter                ;

    ; calculate logicalScreenStart + 8*(X cell coordinate)
    ; multiplication by repeated addition
    ldx #0                              ;
-
    cpx plotX                           ;
    beq +                               ;

    lda plotScreenAddressLow            ; }
    clc                                 ; }
    adc #8                              ; }
    sta plotScreenAddressLow            ; } add eight to screen address (plotScreenAddress)
    lda plotScreenAddressHigh           ; }
    adc #0                              ; }
    sta plotScreenAddressHigh           ; }

    inx                                 ;
    jmp -                               ;

; ***************************************************************************************
; add the Y cells component
; add $280*(plotY) to plotScreenAddress
+
    ldx #0                              ; loop counter
-
    cpx plotY                           ; multiplication by repeated addition
    beq +                               ;

    lda plotScreenAddressLow            ; }
    clc                                 ; }
    adc #$80                            ; }
    sta plotScreenAddressLow            ; } add $0280 to screen address (plotScreenAddress)
    lda plotScreenAddressHigh           ; }
    adc #$02                            ; }
    sta plotScreenAddressHigh           ; }

    inx                                 ;
    jmp -                               ;

; ***************************************************************************************
; add the Y offset within a cell
+
    lda plotScreenAddressLow            ; }
    clc                                 ; }
    adc plotYOffset                     ; }
    sta plotScreenAddressLow            ; } add ($74) to screen address
    lda plotScreenAddressHigh           ; }
    adc #0                              ; }
    sta plotScreenAddressHigh           ; }

spriteDrawRow
    ldy #0                              ;
getSourceByte
    jsr $ffff                           ; call routine to get source byte
    sta (plotScreenAddressLow),y        ; store on screen
    tya                                 ; }
    clc                                 ; }
    adc #8                              ; } Y += 8
    tay                                 ; }
    cpy #32                             ;
    bne getSourceByte                   ; copy 32 bytes

    inc spriteRowCounter                ;
    lda spriteRowCounter                ;
    cmp #16                             ;
    beq return3                         ;
    and #7                              ;
    cmp #0                              ;
    beq add24ToSourceAddress            ;

plotContinues
    inc plotYOffset                     ;

    lda plotScreenAddressLow            ; }
    clc                                 ; }
    adc #1                              ; }
    sta plotScreenAddressLow            ; } add 1 to (plotScreenAddress), the screen address
    lda plotScreenAddressHigh           ; }
    adc #0                              ; }
    sta plotScreenAddressHigh           ; }

    lda plotSourceSpriteAddressLow      ; }
    clc                                 ; }
    adc #1                              ; }
    sta plotSourceSpriteAddressLow      ; } add 1 to ($77,$78), the source sprite
    lda plotSourceSpriteAddressHigh     ; }
    adc #0                              ; }
    sta plotSourceSpriteAddressHigh     ; }

    lda $79                             ; }
    clc                                 ; }
    adc #1                              ; }
    sta $79                             ; } add 1 to ($79, $7a)
    lda $7a                             ; }
    adc #0                              ; }
    sta $7a                             ; }

    lda plotYOffset                     ;
    cmp #8                              ;
    beq spriteMoveToNextRow             ;
    jmp spriteDrawRow                   ;

; ***************************************************************************************
getSpriteDefaultModeByte
    lda (plotSourceSpriteAddressLow),y  ; read source sprite
    and spriteColourMask                ; AND with mask
    ora (plotScreenAddressLow),y        ; OR with screen
    rts                                 ;

; ***************************************************************************************
getSpriteMode2Byte
    lda #0                              ;
    rts                                 ;

; ***************************************************************************************
getSpriteMode10Byte
    lda (plotSourceSpriteAddressLow),y  ; read source sprite
    and #$f0                            ; AND with bit pattern for colour 2
    eor (plotScreenAddressLow),y        ; EOR with screen
    rts                                 ;

; ***************************************************************************************
getSpriteMode3Byte
    lda (plotSourceSpriteAddressLow),y  ; read source sprite
    and spriteColourMask                ; AND with mask
    rts                                 ;

; ***************************************************************************************
getSpriteMode4Byte
    lda (plotScreenAddressLow),y        ; read screen
    cmp #$ff                            ;
    bne getSpriteMode3Byte              ; if (not four pixels of colour 3) then use mode 3
    rts                                 ;

; ***************************************************************************************
getSpriteMode5Byte
    lda (plotScreenAddressLow),y        ; read screen
    cmp #$ff                            ;
    bne getSpriteMode2Byte              ; if (not four pixels of colour 3) then use mode 2
    rts                                 ;

; ***************************************************************************************
add24ToSourceAddress
    lda plotSourceSpriteAddressLow      ; }
    clc                                 ; }
    adc #$18                            ; }
    sta plotSourceSpriteAddressLow      ; } add 24 to source sprite address
    lda plotSourceSpriteAddressHigh     ; }
    adc #0                              ; }
    sta plotSourceSpriteAddressHigh     ; }

    lda $79                             ; }
    clc                                 ; }
    adc #$19                            ; }
    sta $79                             ; } add 25 to ($79,$7A)
    lda $7a                             ; }
    adc #0                              ; }
    sta $7a                             ; }
    jmp plotContinues                   ;

; ***************************************************************************************
return3
    rts                                 ;

screenCharacterAPrime
    !byte $ea

; ***************************************************************************************
spriteMoveToNextRow
    lda #0                              ;
    sta plotYOffset                     ;

    lda plotScreenAddressLow            ; }
    clc                                 ; }
    adc #$78                            ; }
    sta plotScreenAddressLow            ; }
    lda plotScreenAddressHigh           ; } $0278 to (plotScreenAddress)
    adc #2                              ; }
    sta plotScreenAddressHigh           ; }

    jmp spriteDrawRow                   ;

; ***************************************************************************************
showCrumble
    ldy #7                              ; loop counter
-
    lda (plotScreenAddressLow),y        ;
    iny                                 ;
    sta (plotScreenAddressLow),y        ;
    tya                                 ;
    clc                                 ;
    adc #7                              ;
    tay                                 ;
    lda (plotScreenAddressLow),y        ;
    iny                                 ;
    sta (plotScreenAddressLow),y        ;
    tya                                 ;
    sec                                 ;
    sbc #8                              ;
    tay                                 ;
    dey                                 ;
    dey                                 ;
    cpy #0                              ;
    bne -                               ;
    lda #0                              ;
    ldy #1                              ;
    sta (plotScreenAddressLow),y        ;
    ldy #9                              ;
    sta (plotScreenAddressLow),y        ;
    rts                                 ;

; ***************************************************************************************
spriteColourMask
    !byte $ff                           ;

; ***************************************************************************************
updatePlayer
    lda #$ff                            ;
    sta spriteColourMask                ; colour 3
    lda #0                              ;
    sta willyDeltaX                     ;
    sta willyJustLandedOnConveyor       ;
    lda isJumping                       ;
    cmp #0                              ;
    beq handleNotJumping                ;
    jmp handleJumping                   ;

; ***************************************************************************************
handleNotJumping
    ldx #0                                  ; loop counter
-
    lda willySpriteAddressLow,x             ; }
    sta $77,x                               ; }
    inx                                     ; } copy 5 bytes from ($1842-$1846) to ($77-$7B)
    cpx #5                                  ; }
    bne -                                   ; }

    lda #31                                 ; }
    jsr OSWRCH                              ; }
    lda playerPixelX                        ; }
    lsr                                     ; }
    lsr                                     ; }
    jsr OSWRCH                              ; } TAB(playerX/4, playerY/8+2)
    lda playerPixelY                        ; }
    lsr                                     ; }
    lsr                                     ; }
    lsr                                     ; }
    clc                                     ; }
    adc #2                                  ; }
    jsr OSWRCH                              ; }

    jsr readTwoCharactersFromScreen         ; read the two characters immediately lower on screen than the player
    lda playerPixelY                        ;
    and #7                                  ;
    cmp #0                                  ;
    bne handleInAirMovement                 ; if (not on the ground) then branch

    ; Update crumble bars next
    lda plotScreenAddressLow                ; }
    clc                                     ; }
    adc #$78                                ; }
    sta plotScreenAddressLow                ; } (plotScreenAddress) += $278
    lda plotScreenAddressHigh               ; } address of next row down on screen
    adc #2                                  ; }
    sta plotScreenAddressHigh               ; }

    lda screenCharacterA                    ;
    jsr isCrumbleBar                        ;
    cmp #1                                  ;
    beq updateLeftCrumbleBar                ;
afterUpdateCrumberBar
    lda plotScreenAddressLow                ;
    clc                                     ;
    adc #16                                 ; add 16 to the address on screen

    ; this code continues after the following graphics at $1100
    }
}

!pseudopc $0800 {
    ; OS sound workspace
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $c0, $c0, $c0, $c0, $04, $04, $04, $04
    !byte $00, $64, $00, $00, $00, $00, $00, $00, $00, $1f, $00, $00, $00, $00, $00, $00
    !byte $00, $05, $00, $00, $00, $30, $00, $00, $00, $01, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $8a, $00, $00, $ff, $fd, $c1, $00, $00, $f0, $00, $0e

    ; OS sound buffers
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $01, $01, $00, $64, $01, $08, $64, $01, $10, $64, $01, $18, $64, $01, $00, $f8
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

    ; OS printer buffer [UNUSED]
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

    ; OS Envelope definitions
    !byte $01, $78, $00, $00, $1e, $00, $00, $7e, $ff, $00, $ff, $7e, $5a, $00, $00, $00
    !byte $01, $00, $00, $00, $01, $01, $01, $7f, $ff, $ff, $fe, $7e, $01, $00, $00, $00
    !byte $05, $10, $00, $00, $07, $00, $00, $20, $f6, $fe, $fe, $7e, $64, $00, $00, $00
    !byte $01, $02, $00, $00, $64, $00, $00, $7e, $00, $00, $fe, $7e, $7e, $00, $00, $00

    ; data for pseudo pc $0900-$0cff is EORing with #$AA
!xor $aa {
spriteStart
    ; skull and crossbones
    !byte %.....###            ;      ######
    !byte %....####            ;     ########
    !byte %....#..#            ;     #  ##  #
    !byte %....#..#            ;     #  ##  #
    !byte %....####            ;     ########
    !byte %.....#.#            ;      # ## #
    !byte %.....##.            ;      ##  ##
    !byte %......##            ;       ####
                               ;  ###   ## #####
    !byte %###.....            ; #####    #######
    !byte %####....            ; ####### ########
    !byte %#..#....            ;     ## ###  ###
    !byte %#..#....            ;  ###  ### ##
    !byte %####....            ; ######## #######
    !byte %#.#.....            ; #######    #####
    !byte %.##.....            ;  #####      ###
    !byte %##......

    !byte %.###...#
    !byte %#####...
    !byte %#######.
    !byte %....##.#
    !byte %.###..##
    !byte %########
    !byte %#######.
    !byte %.#####..

    !byte %#.#####.
    !byte %.#######
    !byte %########
    !byte %##..###.
    !byte %#.##....
    !byte %.#######
    !byte %...#####
    !byte %....###.

    ; star box (top)
    !byte %########
    !byte %#.......
    !byte %#.######
    !byte %#.######
    !byte %#.##.###
    !byte %#..#.#.#
    !byte %#.#...##
    !byte %#.......

    !byte %########
    !byte %.......#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %##...#.#

    !byte %#.#...##
    !byte %#..#.#.#
    !byte %#.##.###
    !byte %#.######
    !byte %#.######
    !byte %#.######
    !byte %#.......
    !byte %########

    !byte %#.###..#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %######.#
    !byte %.......#
    !byte %########

    !byte %########
    !byte %.#...#..
    !byte %#..##..#
    !byte %..#...#.
    !byte %..#...#.
    !byte %#..##..#
    !byte %.#...#..
    !byte %.#...#..

    !byte %########
    !byte %.#...#..
    !byte %#..##..#
    !byte %..#...#.
    !byte %..#...#.
    !byte %#..##..#
    !byte %.#...#..
    !byte %.#...#..

    !byte %#..##..#
    !byte %..#...#.
    !byte %..#...#.
    !byte %#..##..#
    !byte %.#...#..
    !byte %.#...#..
    !byte %#..##..#
    !byte %########

    !byte %#..##..#
    !byte %..#...#.
    !byte %..#...#.
    !byte %#..##..#
    !byte %.#...#..
    !byte %.#...#..
    !byte %#..##..#
    !byte %########

    !byte %########
    !byte %#...#...
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#...#...
    !byte %##.###.#
    !byte %##.#...#
    !byte %##.#.#.#

    !byte %########
    !byte %#..#####
    !byte %#.##...#
    !byte %#.##.#.#
    !byte %#....#.#
    !byte %..###..#
    !byte %.#####.#
    !byte %.#.#.#.#

    !byte %##.#.#.#
    !byte %##.#...#
    !byte %##.###.#
    !byte %#...##.#
    !byte %#.#.#...
    !byte %#.#.#.#.
    !byte %#...#...
    !byte %########

    !byte %.#...#.#
    !byte %.#####.#
    !byte %#.###.##
    !byte %#.....##
    !byte %#.#.#.##
    !byte %#.#.#.##
    !byte %#...#..#
    !byte %########

    !byte %########
    !byte %#..##..#
    !byte %#.###.##
    !byte %########
    !byte %########
    !byte %#..##..#
    !byte %#.###.##
    !byte %########

    !byte %#...#...
    !byte %.#...#..
    !byte %..#...#.
    !byte %...#...#
    !byte %#...#...
    !byte %.#...#..
    !byte %..#...#.
    !byte %...#...#

    !byte %########
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.

    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %#..#..#.
    !byte %########

    !byte %########
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#...####
    !byte %#...####
    !byte %#...##..
    !byte %######..

    !byte %######..
    !byte %#...##..
    !byte %#...####
    !byte %#...####
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %##......
    !byte %#.#.....
    !byte %##.#....
    !byte %#.#.#...
    !byte %#..#.#..

    !byte %#...#.#.
    !byte %##...#.#
    !byte %#.#...#.
    !byte %#..#...#
    !byte %#...#..#
    !byte %#..#..#.
    !byte %#.#..#..
    !byte %########

    !byte %########
    !byte %#......#
    !byte %#.....#.
    !byte %#....#..
    !byte %#...#...
    !byte %#..#....
    !byte %#.#....#
    !byte %##....##

    !byte %##....##
    !byte %#.#....#
    !byte %#..#....
    !byte %#...#...
    !byte %#....#..
    !byte %#.....#.
    !byte %#......#
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %#...####
    !byte %#...####
    !byte %#...####
    !byte %#...##..
    !byte %#...##..

    !byte %#...##..
    !byte %#...##..
    !byte %#...####
    !byte %#...####
    !byte %#...####
    !byte %#.......
    !byte %#.......
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %#.......
    !byte %#....###
    !byte %#...#...
    !byte %#..#....
    !byte %#..#...#

    !byte %#..#...#
    !byte %#..#....
    !byte %#...#...
    !byte %#....###
    !byte %#.......
    !byte %#.......
    !byte %#.......
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %########
    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %########

    ; $0a00
    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %########
    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.######
    !byte %#.#.....
    !byte %#.#.####
    !byte %#.#.#...
    !byte %#.#.#.##
    !byte %#.#.#.#.

    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.......
    !byte %#..#####
    !byte %#..#....
    !byte %#..#.##.
    !byte %#..#.##.
    !byte %#..#.##.

    !byte %#..#.##.
    !byte %#..#.##.
    !byte %#..#.##.
    !byte %#..#....
    !byte %#..#####
    !byte %#.......
    !byte %#.......
    !byte %########

    !byte %########
    !byte %#.......
    !byte %#.######
    !byte %#.#.....
    !byte %#.#.####
    !byte %#.#.#...
    !byte %#.#.#.##
    !byte %#.#.#.#.

    !byte %#.#.#.#.
    !byte %#.#.#.##
    !byte %#.#.#...
    !byte %#.#.####
    !byte %#.#.....
    !byte %#.######
    !byte %#.......
    !byte %########

    !byte %....####
    !byte %...#####
    !byte %..######
    !byte %..####..
    !byte %..###...
    !byte %..###...
    !byte %..###...
    !byte %..###...

    !byte %..###...
    !byte %...###..
    !byte %....###.
    !byte %....###.
    !byte %##..###.
    !byte %#######.
    !byte %######..
    !byte %........

    !byte %..###...
    !byte %...###..
    !byte %....###.
    !byte %....###.
    !byte %##..###.
    !byte %#######.
    !byte %######..
    !byte %........

    !byte %...###..
    !byte %..###...
    !byte %.###....
    !byte %.###....
    !byte %.###..##
    !byte %.#######
    !byte %..######
    !byte %........

spikePlant
    !byte %.#...#..
    !byte %..#.#...
    !byte %.#.#.#..
    !byte %..##...#
    !byte %#..#.#.#
    !byte %.###.##.
    !byte %...##...
    !byte %...#....

allOtherSpikes
    !byte %.######.
    !byte %..####..
    !byte %...###..
    !byte %...##...
    !byte %...##...
    !byte %....#...
    !byte %....#...
    !byte %........

    !byte %########
    !byte %#######.
    !byte %.######.
    !byte %.#..##..
    !byte %.#..##..
    !byte %....#...
    !byte %....#...
    !byte %........

    !byte %....#...
    !byte %.##.#.##
    !byte %...###..
    !byte %.##.#.##
    !byte %...###..
    !byte %..#...#.
    !byte %.##...##
    !byte %...#.#..

    !byte %.##...##
    !byte %...#.#..
    !byte %...###..
    !byte %.##.#.##
    !byte %...###..
    !byte %..#...#.
    !byte %.##...##
    !byte %...#.#..

    !byte %..####..
    !byte %...##...
    !byte %#.####.#
    !byte %###..###
    !byte %###..###
    !byte %#.####.#
    !byte %...##...
    !byte %..####..

    !byte %#.#.#.#.
    !byte %.#...#..
    !byte %..###...
    !byte %##.#.##.
    !byte %..###...
    !byte %.#####..
    !byte %#.#.#.#.
    !byte %..#.#...

    !byte %.#..#...
    !byte %#.#.#.#.
    !byte %.#.###.#
    !byte %....#.#.
    !byte %.####...
    !byte %#.#.###.
    !byte %#.#.#..#
    !byte %.#...###

    !byte %.#...#..
    !byte %.#...#..
    !byte %.#...#..
    !byte %.#...#..
    !byte %.##..##.
    !byte %###.###.
    !byte %###.###.
    !byte %########

    !byte %##....##
    !byte %.##..##.
    !byte %..####..
    !byte %..#..#..
    !byte %..#..#..
    !byte %..####..
    !byte %.##..##.
    !byte %##....##

    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...

    !byte %..##....
    !byte %.#..#...
    !byte %#...#...
    !byte %#..#....
    !byte %.##.#...
    !byte %.....#..
    !byte %....#.#.
    !byte %.....#..

    !byte %.#.#....
    !byte %#.#.#...
    !byte %.#.#.#..
    !byte %#.#.#...
    !byte %.#.##...
    !byte %..#..#..
    !byte %......#.
    !byte %.......#

    !byte %...#####
    !byte %..#...##
    !byte %.#...###
    !byte %########
    !byte %#...####
    !byte %#...###.
    !byte %#...##..
    !byte %#####...

    !byte %##......
    !byte %###.##..
    !byte %.###..#.
    !byte %..#.#...
    !byte %.#.#.#..
    !byte %.#..#.#.
    !byte %.....###
    !byte %........

    !byte %....#...
    !byte %....#...
    !byte %.######.
    !byte %#.######
    !byte %#..#####
    !byte %#...####
    !byte %##....##
    !byte %.######.

    !byte %...##...
    !byte %.##..##.
    !byte %.#....#.
    !byte %##.##..#
    !byte %##..#..#
    !byte %.##...#.
    !byte %.######.
    !byte %...##...

    !byte %..####..
    !byte %.#.##.#.
    !byte %#..#.#.#
    !byte %##.#.#.#
    !byte %##.#.#.#
    !byte %##.#.#.#
    !byte %.#.##.#.
    !byte %..####..

    !byte %#.#.#.#.
    !byte %#.#.#.#.
    !byte %#######.
    !byte %#######.
    !byte %#######.
    !byte %#######.
    !byte %#.#.#.#.
    !byte %#.#.#.#.

    !byte %.######.
    !byte %..####..
    !byte %.##..##.
    !byte %##.#####
    !byte %#...####
    !byte %##.#####
    !byte %#.....##
    !byte %.######.

    !byte %....####
    !byte %....#..#
    !byte %..######
    !byte %..#..#..
    !byte %######..
    !byte %#..#....
    !byte %####....
    !byte %........

    !byte %########
    !byte %########
    !byte %##.##.##
    !byte %..#.###.
    !byte %##...#.#
    !byte %..#.....
    !byte %........
    !byte %........

    !byte %########
    !byte %########
    !byte %.##..##.
    !byte %#..##..#
    !byte %.##..##.
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %########
    !byte %########
    !byte %#..##..#
    !byte %#..##..#
    !byte %########
    !byte %#..##..#
    !byte %.##..##.
    !byte %........

    !byte %..####..
    !byte %########
    !byte %###.####
    !byte %##.#####
    !byte %...###..
    !byte %....#...
    !byte %....#...
    !byte %....#...

    !byte %########
    !byte %########
    !byte %###.#.#.
    !byte %#..#.#.#
    !byte %.#..#.#.
    !byte %#.#..#.#
    !byte %.#.#....
    !byte %#....###

    !byte %########
    !byte %########
    !byte %...#...#
    !byte %..#...#.
    !byte %.#...#..
    !byte %#...#...
    !byte %########
    !byte %########

    !byte %########
    !byte %########
    !byte %.##...#.
    !byte %.##..#..
    !byte %.##.#...
    !byte %.###....
    !byte %.##.....
    !byte %.##.....

    !byte %########
    !byte %########
    !byte %.#...##.
    !byte %..#..##.
    !byte %...#.##.
    !byte %....###.
    !byte %.....##.
    !byte %.....##.

    !byte %..#...#.
    !byte %########
    !byte %#...#...
    !byte %########
    !byte %..#...#.
    !byte %########
    !byte %#...#...
    !byte %########

    !byte %#......#
    !byte %##....##
    !byte %#.#..#.#
    !byte %#..##..#
    !byte %#..##..#
    !byte %#.#..#.#
    !byte %##....##
    !byte %#......#

    !byte %#######.
    !byte %.#####.#
    !byte %..###.##
    !byte %...#.###
    !byte %...#####
    !byte %..#..###
    !byte %.#....##
    !byte %#......#

    !byte %##.##.##
    !byte %##.##.##
    !byte %##.##.##
    !byte %##.##.##
    !byte %#.##.#..
    !byte %#.###.##
    !byte %##.##.##
    !byte %##.##.##

    !byte %########
    !byte %#......#
    !byte %#......#
    !byte %########
    !byte %########
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########
    !byte %#..##..#
    !byte %#.###.##
    !byte %########
    !byte %########
    !byte %#..##..#
    !byte %#.###.##
    !byte %########

    !byte %########
    !byte %#.#..#.#
    !byte %#.#..#.#
    !byte %#.#..#.#
    !byte %#.#..#.#
    !byte %#.#..#.#
    !byte %#.#..#.#
    !byte %########

    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########
    !byte %########

    !byte %########
    !byte %##.##.##
    !byte %..#..#..
    !byte %.#.#.#..
    !byte %..#...#.
    !byte %........
    !byte %........
    !byte %........

    !byte %########
    !byte %########
    !byte %..##..##
    !byte %##..##..
    !byte %..#....#
    !byte %....##..
    !byte %###..#.#
    !byte %........

    !byte %..####..
    !byte %########
    !byte %####.###
    !byte %....##..
    !byte %...##...
    !byte %...#....
    !byte %...#....
    !byte %...#....

    !byte %########
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...

    !byte %#######.                 ; conveyor 1
    !byte %.##..##.
    !byte %#######.
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %#####.##
    !byte %.##..##.
    !byte %#.######
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %###.####
    !byte %.##..##.
    !byte %###.####
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %#.######
    !byte %.##..##.
    !byte %#####.##
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %##....##                 ; conveyor 2
    !byte %.##..##.
    !byte %...##...
    !byte %.##..##.
    !byte %........
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %....####
    !byte %.##..##.
    !byte %....####
    !byte %.##..##.
    !byte %........
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %#......#
    !byte %.##..##.
    !byte %........
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %####....
    !byte %.##..##.
    !byte %####....
    !byte %.##..##.
    !byte %........
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %##....##                 ; conveyor 3
    !byte %.##..##.
    !byte %...##...
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %....####
    !byte %.##..##.
    !byte %....####
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %..####..
    !byte %.##..##.
    !byte %#......#
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %####....
    !byte %.##..##.
    !byte %####....
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %########                 ; char 128 ($80, $A0, $C0, $E0)
    !byte %########
    !byte %##.##.##
    !byte %..#.###.
    !byte %##...#.#
    !byte %..#.....
    !byte %........
    !byte %........

    !byte %########                 ; char 129 ($81, $A1, $C1, $E1)
    !byte %########
    !byte %.##..##.
    !byte %#..##..#
    !byte %.##..##.
    !byte %#..##..#
    !byte %########
    !byte %........

    !byte %########                 ; char 130 ($82, $A2, $C2, $E2)
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...

    !byte %........                 ; char 131 ($83, $A3, $C3, $E3)
    !byte %########
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.

    !byte %........                 ; char 132 ($84, $A4, $C4, $E4)
    !byte %........
    !byte %########
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...

    !byte %........                 ; char 133 ($85, $A5, $C5, $E5)
    !byte %........
    !byte %........
    !byte %########
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...
    !byte %..#...#.

    !byte %........                 ; char 134 ($86, $A6, $C6, $E6)
    !byte %........
    !byte %........
    !byte %........
    !byte %########
    !byte %#...#...
    !byte %..#...#.
    !byte %#...#...

    !byte %........                 ; char 135 ($87, $A7, $C7, $E7)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %########
    !byte %#...#...
    !byte %..#...#.

    !byte %........                 ; char 136 ($88, $A8, $C8, $E8)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %########
    !byte %#...#...

    !byte %........                 ; char 137 ($89, $A9, $C9, $E9)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %########

    !byte %........                 ; char 138 ($8A, $AA, $CA, $EA)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %##....##                 ; char 139 ($8B, $AB, $CB, $EB)
    !byte %.##..##.
    !byte %...##...
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %....####                 ; char 140 ($8C, $AC, $CC, $EC)
    !byte %.##..##.
    !byte %....####
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %..####..                 ; char 141 ($8D, $AD, $CD, $ED)
    !byte %.##..##.
    !byte %#......#
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %####....                 ; char 142 ($8E, $AE, $CE, $EE)
    !byte %.##..##.
    !byte %####....
    !byte %.##..##.
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %..#...#.                 ; char 143 ($8F, $AF, $CF, $EF)
    !byte %########
    !byte %#...#...
    !byte %########
    !byte %..#...#.
    !byte %########
    !byte %#...#...
    !byte %########

    !byte %..##....                 ; char 144 ($90, $B0, $D0, $F0)
    !byte %.#..#...
    !byte %#...#...
    !byte %#..#....
    !byte %.##.#...
    !byte %.....#..
    !byte %....#.#.
    !byte %.....#..

    !byte %########                 ; char 145 ($91, $B1, $D1, $F1)
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########                 ; char 146 ($92, $B2, $D2, $F2)
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########                 ; char 147 ($93, $B3, $D3, $F3)
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########                 ; char 148 ($94, $B4, $D4, $F4)
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %########

    !byte %########                 ; char 149 ($95, $B5, $D5, $F5)
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#
    !byte %#......#

    !byte %########                 ; char 150 ($96, $B6, $D6, $F6)
    !byte %########
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...
    !byte %...##...

    !byte %........                 ; char 151 ($97, $B7, $D7, $F7)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %#######.                 ; char 152 ($98, $B8, $D8, $F8)
    !byte %#.....#.
    !byte %#.....#.
    !byte %.#...#..
    !byte %..###...
    !byte %..#.....
    !byte %##......
    !byte %##......

    !byte %#######.                 ; char 153 ($99, $B9, $D9, $F9)
    !byte %#.....#.
    !byte %#.....#.
    !byte %.#...#..
    !byte %..###...
    !byte %....#...
    !byte %.....##.
    !byte %.....##.

    !byte %........                 ; char 154 ($9A, $BA, $DA, $FA)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........                 ; char 155 ($9B, $BB, $DB, $FB)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........                 ; char 156 ($9C, $BC, $DC, $FC)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %........                 ; char 157 ($9D, $BD, $DD, $FD)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........

    !byte %....#...                 ; char 158 ($9E, $BE, $DE, $FE)
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...
    !byte %....#...

    !byte %........                 ; char 159 ($9F, $BF, $DF, $FF)
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
spriteEnd
    }
}

!pseudopc $1100 {
!xor $55 {

    ; $1100
    sta plotScreenAddressLow            ;
    lda plotScreenAddressHigh           ;
    adc #0                              ;
    sta plotScreenAddressHigh           ;
    lda screenCharacterB                ;
    jsr isCrumbleBar                    ;
    cmp #1                              ;
    bne checkForConveyors               ;

    ; crumble the right hand crumble bar (in the background cache)
    ldx #7                              ; loop counter
-
    ; +$50 is to get to the characters underneath the players feet
    lda backgroundCache + $50 - 1,x     ;
    sta backgroundCache + $50 + 0,x     ; copy one pixel row to the next
    lda backgroundCache + $50 + 7,x     ;
    sta backgroundCache + $50 + 8,x     ;
    dex                                 ;
    bne -                               ;

    lda #0                              ;
    sta backgroundCache + $50 + 0       ; zero the top row of crumble bar
    sta backgroundCache + $50 + 8       ;
    jsr showCrumble                     ;
    jmp checkForConveyors               ;

; ***************************************************************************************
updateLeftCrumbleBar
    ldx #7                              ;
-
    ; $40 is to get to the characters underneath the players feet
    lda backgroundCache + $40 - 1,x     ;
    sta backgroundCache + $40 + 0,x     ; copy one pixel row to the next
    lda backgroundCache + $40 + 7,x     ;
    sta backgroundCache + $40 + 8,x     ;
    dex                                 ;
    bne -                               ;

    lda #0                              ;
    sta backgroundCache + $40 + 0       ; zero the top row of crumble bar
    sta backgroundCache + $40 + 8       ;
    jsr showCrumble                     ;
    jmp afterUpdateCrumberBar           ;

; ***************************************************************************************
checkForConveyors
    lda plotScreenAddressLow            ;
    sec                                 ;
    sbc #$88                            ;
    sta plotScreenAddressLow            ; (plotScreenAddress) -= $288
    lda plotScreenAddressHigh           ; move to previous character row
    sbc #$02                            ;
    sta plotScreenAddressHigh           ;
handleInAirMovement
    lda screenCharacterA                ;
    jsr isConveyor                      ;
    cmp #0                              ;
    bne onConveyor                      ;
    lda screenCharacterB                ;
    jsr isConveyor                      ;
    cmp #0                              ;
    bne onConveyor                      ;
    lda #0                              ;
    sta willyIsOnConveyor               ;
onConveyor                              ;
    lda willyIsOnConveyor               ;
    cmp #1                              ;
    bne checkPlayerY                    ;
    lda willyDirectionAgainstFlowOfConveyor ;
    cmp #0                              ;
    bne checkPlayerY                    ;
    jmp checkForUpdatePlayerOnConveyor  ;

; ***************************************************************************************
checkPlayerY
    lda playerPixelY                    ;
    and #7                              ;
    cmp #0                              ;
    beq checkIfSupported                ;
updatePlayerFalling
    lda newPlayerPixelY                 ;
    clc                                 ;
    adc #2                              ;
    sta newPlayerPixelY                 ;
    jmp checkIfBlockedLeftOrRight       ;

; ***************************************************************************************
checkIfSupported
    lda screenCharacterA                ;
    jsr isSupporting                    ;
    cmp #1                              ;
    beq onGround                        ;
    lda screenCharacterB                ;
    jsr isSupporting                    ;
    cmp #1                              ;
    beq onGround                        ;
    lda #1                              ;
    sta willyFalling                    ;
    jmp updatePlayerFalling             ;

; ***************************************************************************************
onGround
    lda #0                                  ;
    sta willyChangedDirection               ;

    ldy #$ff                                ;
    ldx #$9e                                ;
    lda #$81                                ; check for Z key
    jsr OSBYTE                              ;
    cpy #$ff                                ;
    bne checkForXKey                        ;

    ; handle Z pressed
    lda willyAnimationEOR                   ;
    cmp #3                                  ;
    bne switchToLookingLeft                 ; if (looking right) then branch
    lda #$ff                                ;
    sta willyDeltaX                         ;
    lda newPlayerPixelX                     ;
    sec                                     ; move left
    sbc #1                                  ;
    sta newPlayerPixelX                     ;
    jmp checkForUpdatePlayerOnConveyor      ; adjust for conveyor

; ***************************************************************************************
switchToLookingLeft
    lda #3                                  ; }
    sta willyAnimationEOR                   ; }
    lda #>willyLeft0                        ; } look left
    sta willyGraphicsPage                   ; }
    lda #1                                  ;
    sta willyChangedDirection               ;
    jsr checkIfBlockedLeftOrRight           ;
    lda #0                                  ;
    sta willyDeltaX                         ;
    jmp checkForUpdatePlayerOnConveyor      ;

; ***************************************************************************************
checkForXKey
    ldy #$ff                                ; }
    ldx #$bd                                ; }
    lda #$81                                ; } check for X key
    jsr OSBYTE                              ; }
    cpy #$ff                                ; }
    bne checkForUpdatePlayerOnConveyor      ; }

    ; handle X pressed
    lda willyAnimationEOR                   ;
    cmp #0                                  ;
    bne switchToLookingRight                ; if (looking left) then branch
    lda #1                                  ;
    sta willyDeltaX                         ;

    lda newPlayerPixelX                     ;
    clc                                     ;
    adc #1                                  ; add one to player x
    sta newPlayerPixelX                     ;

    jmp checkForUpdatePlayerOnConveyor

; ***************************************************************************************
switchToLookingRight
    lda #0                                  ; }
    sta willyAnimationEOR                   ; }
    lda #>willyRight0                       ; } look right
    sta willyGraphicsPage                   ; }
    lda #1                                  ;
    sta willyChangedDirection               ;
    jsr checkIfBlockedLeftOrRight           ;
    lda #0                                  ;
    sta willyDeltaX                         ;

checkForUpdatePlayerOnConveyor
    lda #31                                 ; }
    jsr OSWRCH                              ; }
    lda playerPixelX                        ; }
    lsr                                     ; }
    lsr                                     ; }
    jsr OSWRCH                              ; } TAB(playerX/4, playerY/8+2)
    lda playerPixelY                        ; }
    lsr                                     ; }
    lsr                                     ; }
    lsr                                     ; }
    clc                                     ; }
    adc #2                                  ; }
    jsr OSWRCH                              ; }

    jsr readTwoCharactersFromScreen         ; read the two characters immediately lower on screen than the player
    lda willyIsOnConveyor                   ;
    cmp #0                                  ;
    bne handleGoingOnConveyor               ;
    lda screenCharacterA                    ;
    jsr isConveyor                          ;
    cmp #1                                  ;
    beq +                                   ;
    lda screenCharacterB                    ;
    jsr isConveyor                          ;
    cmp #1                                  ;
    bne handleGoingOnConveyor               ;
+
    lda willyDeltaX                         ;
    sta willyDirectionAgainstFlowOfConveyor ;
    lda #1                                  ;
    sta willyIsOnConveyor                   ;
handleGoingOnConveyor
    lda willyIsOnConveyor                   ;
    cmp #1                                  ;
    bne conveyorHandling                    ;

    ; handle on conveyor
    lda willyFalling                        ;
    cmp #1                                  ;
    bne +                                   ;
    lda willyDeltaX                         ;
    eor #$fe                                ;
    cmp conveyorDirection                   ;
    bne +                                   ;
    lda #$fe                                ;
    sta willyDirectionAgainstFlowOfConveyor ;
+
    lda willyFalling                        ;
    cmp #1                                  ;
    bne conveyorNotFalling                  ;
    lda #$fe                                ;
    sta willyDirectionAgainstFlowOfConveyor ;
updateNewPlayerX
    lda newPlayerPixelX                     ;
    sec                                     ;
    sbc willyDeltaX                         ;
    sta newPlayerPixelX                     ;
    jmp checkForJump                        ;

; ***************************************************************************************
conveyorNotFalling
    lda willyDirectionAgainstFlowOfConveyor ;
    cmp #$fe                        ;
    bne conveyorHandling            ;
    lda willyDeltaX                 ;
    eor #$fe                        ;
    cmp conveyorDirection           ;
    bne conveyorHandling            ;
    jmp updateNewPlayerX            ;

; ***************************************************************************************
conveyorHandling
    lda willyDeltaX                 ;
    cmp #0                          ;
    beq movingWithConveyor          ;
    lda willyDeltaX                 ;
    cmp conveyorDirection           ;
    bne +                           ;
movingWithConveyor
    lda #0                          ;
    sta willyDirectionAgainstFlowOfConveyor ;
+
    lda willyDirectionAgainstFlowOfConveyor ;
    cmp #0                          ;
    bne +                           ;
    lda willyIsOnConveyor           ;
    cmp #1                          ;
    bne +                           ;
    jsr updateWillyOnConveyor       ;
+
    lda willyDeltaX                 ;
    sta jumpDirection               ;
    cmp #0                          ;
    beq checkForJump                ;
    jsr checkIfBlockedLeftOrRight   ;
checkForJump
    ldy #$ff                        ;
    ldx #$b6                        ;
    lda #$81                        ;
    jsr OSBYTE                      ; check for RETURN key pressed
    cpy #$ff                        ;
    bne cancelJump                  ; if (return not pressed) then branch (no jump)

    ; handle jump
    lda willyJustLandedOnConveyor   ;
    cmp #0                          ;
    bne cancelJump                  ;
    lda willyFalling                ;
    cmp #0                          ;
    bne cancelJump                  ;
    jmp checkForWallOnJump          ;

; ***************************************************************************************
cancelJump
    lda #0                          ;
    sta willyDeltaX                 ;
    sta playerYNegativeOffsetWithinCell     ;
    sta willyFalling                ;
    sta jumpDirection               ;
    lda hasDrawnConveyors           ;
    cmp #0                          ;
    beq +                           ;
    lda #0                          ;
    sta hasDrawnConveyors           ;
    rts                             ;

; ***************************************************************************************
+
    jsr updatePlayerAirAndDrawConveyor  ;
    jmp updatePlayerWithAnimation   ;

    ; $1335
; ***************************************************************************************
checkForWallOnJump
    lda #31                         ;
    jsr OSWRCH                      ;
    lda newPlayerPixelX             ;
    lsr                             ;
    lsr                             ;
    jsr OSWRCH                      ;
    lda newPlayerPixelY             ;
    lsr                             ; TAB(newPlayerPixelX/4, newPlayerPixelY/8 - 1)
    lsr                             ;
    lsr                             ;
    sec                             ;
    sbc #1                          ;
    jsr OSWRCH                      ;

    jsr readTwoCharactersFromScreen ; read the two characters immediately higher on screen than the player
    lda screenCharacterA            ;
    cmp #$8f                        ;
    beq foundWallSoCancelJump       ; if (wall) then branch
    lda screenCharacterB            ;
    cmp #$8f                        ;
    beq foundWallSoCancelJump       ; if (wall) then branch

    ; start jump
    lda #1                          ;
    sta isJumping                   ;
    lda playerPixelY                ;
    sta playerHeightOnTakeOff       ;
    lda #0                          ;
    sta jumpPhase                   ;
    jmp handleJumping               ;

; ***************************************************************************************
foundWallSoCancelJump
    jmp cancelJump                  ;

; ***************************************************************************************
checkIfBlockedLeftOrRight
    lda #0                              ;
    sta screenCharacterAPrime           ;
    sta playerYNegativeOffsetWithinCell ;
    lda newPlayerPixelY                 ;
    and #7                              ;
    cmp #0                              ;
    beq onCellFloor                     ;

    ; handle having a vertical gap from the cell floor
    sta playerXOffsetWithinCell         ; just used as temporary storage
    lda #$ff                            ;
    clc                                 ;
    sbc playerXOffsetWithinCell         ;
    sta playerYNegativeOffsetWithinCell ;
onCellFloor
    lda newPlayerPixelX                 ;
    and #3                              ;
    sta playerXOffsetWithinCell         ;
    lda playerXOffsetWithinCell         ;
    cmp #3                              ;
    bne +                               ;
    lda willyDeltaX                     ;
    cmp #$ff                            ;
    bne +                               ;
    jsr checkWhatsLeftOfThePlayer       ;
+
    lda willyDeltaX                     ;
    cmp #$fd                            ;
    bne +                               ;

    ; handle being blocked to the left
    ; add one back onto the new X position
    lda newPlayerPixelX                 ;
    clc                                 ;
    adc #1                              ;
    sta newPlayerPixelX                 ;
    lda #0                              ;
    sta willyDeltaX                     ;
    jmp updateNewPlayerY                ;

; ***************************************************************************************
+
    lda playerXOffsetWithinCell         ;
    cmp #0                              ;
    bne +                               ;
    lda willyDeltaX                     ;
    cmp #1                              ;
    bne +                               ;
    jsr checkWhatsRightOfThePlayer      ;
+
    lda willyDeltaX                     ;
    cmp #$fe                            ;
    bne +                               ;

    ; handle being blocked to the right
    ; subtract one for the new X position
    lda newPlayerPixelX                 ;
    sec                                 ;
    sbc #1                              ;
    sta newPlayerPixelX                 ;
    lda #0                              ;
    sta willyDeltaX                     ;
    jmp updateNewPlayerY                ;

; ***************************************************************************************
+
    jmp updateConveyorsAndPlayer        ;

; ***************************************************************************************
updateNewPlayerY
    lda playerPixelY                ;
    cmp playerHeightOnTakeOff       ;
    bne updateConveyorsAndPlayer    ; if (player height not the same as when last on ground) then branch (move player)

    lda jumpPhase                   ;
    cmp #0                          ;
    bne updateConveyorsAndPlayer    ; if (jumping) then branch (move player)

    lda newPlayerPixelY             ;
    sta playerPixelY                ;
    rts                             ;

; ***************************************************************************************
updateConveyorsAndPlayer

    ldx playerPixelX                    ; }
    ldy playerPixelY                    ; }
    lda #0                              ; }
    jsr readOrWriteCachedBackground     ; } draw old background from cache

    jsr updatePlayerAirAndDrawConveyor  ; animate conveyors

    lda #1                              ;
    sta hasDrawnConveyors               ;

    ldx newPlayerPixelX                 ; }
    ldy newPlayerPixelY                 ; }
    lda #1                              ; }
    jsr readOrWriteCachedBackground     ; } cache new background

; ***************************************************************************************
updatePlayerWithAnimation
    lda #0                              ;
    sta plotSourceSpriteAddressLow      ;
    lda willyGraphicsPage               ; sprite address = willy looking right or left
    sta plotSourceSpriteAddressHigh     ;

    lda #$00                            ;
    sta $79                             ; }
    lda #$0d                            ; } $0d00 (?)
    sta $7a                             ; }

    lda newPlayerPixelX                 ;
    and #3                              ;
    eor willyAnimationEOR               ;
    sta $75                             ;

    ldx #0                              ; loop counter
-
    cpx $75                             ; }
    beq drawPlayerAndCheckForSingleItems ; }
    lda plotSourceSpriteAddressLow      ; }
    clc                                 ; } add $40 to ($77,$78) for ($75) times
    adc #$40                            ; } multiplication by repeated addition
    sta plotSourceSpriteAddressLow      ; }
    lda plotSourceSpriteAddressHigh     ; }
    adc #0                              ; }
    sta plotSourceSpriteAddressHigh     ; }
    inx                                 ;
    jmp -                               ;

; ***************************************************************************************
drawPlayerAndCheckForSingleItems
    ldx newPlayerPixelX                 ;
    ldy newPlayerPixelY                 ;
    lda #0                              ;
opcodeForJsrPlot
    jsr plot                            ; draw player (mode 0)
    jsr checkForLandingOnSpike          ;

    lda #31                             ;
    jsr OSWRCH                          ; TAB(34,23)
    lda #34                             ;
    jsr OSWRCH                          ;
    lda #23                             ;
    jsr OSWRCH                          ;

    jsr checkSpikeKeySwitch             ;
    lda #9                              ; forward space
    jsr OSWRCH                          ;
    jsr checkSpikeKeySwitch             ;

    lda newPlayerPixelY                 ;
    and #7                              ;
    cmp #0                              ;
    beq +                               ; if (level with cell vertically) then branch
    lda #9                              ; forward space
    jsr OSWRCH                          ;
    jsr checkSpikeKeySwitch             ;
+
    ; copy local variables back (4 bytes)
    ldx #0                              ;
-
    lda $77,x                           ;
    sta willySpriteAddressLow,x         ;
    inx                                 ;
    cpx #4                              ;
    bne -                               ;

    lda newPlayerPixelX                 ;
    sta playerPixelX                    ;
    lda newPlayerPixelY                 ; store new player position
    sta playerPixelY                    ;
    rts                                 ;

; ***************************************************************************************
readTwoCharactersFromScreen
    lda #135                ;
    jsr OSBYTE              ; read character at cursor position
    stx screenCharacterA    ; store result

    lda #9                  ;
    jsr OSWRCH              ; move forward one space

    lda #135                ;
    jsr OSBYTE              ; read character at cursor position
    stx screenCharacterB    ; store result
    rts

; ***************************************************************************************
readTwoCharactersVertically
    lda #135                ;
    jsr OSBYTE              ; read character at text cursor position
    stx screenCharacterA    ; store result

    lda #$0a                ;
    jsr OSWRCH              ; move text cursor down one cell

    lda #135                ;
    jsr OSBYTE              ; read character at text cursor position
    stx screenCharacterB    ; store result
    rts                     ;

; ***************************************************************************************
checkSpikeKeySwitch
    jsr readTwoCharactersFromScreen                 ;
    lda #8                                          ;
    jsr OSWRCH                                      ; move back one character
    lda screenCharacterA                            ; first character
    jsr checkForSpikeKeySwitchCollisions            ;
    lda #9                                          ; tab forwards
    jsr OSWRCH                                      ;
    lda screenCharacterB                            ; second character
    jmp checkForSpikeKeySwitchCollisions            ;

; ***************************************************************************************
checkForSpikeKeySwitchCollisions
    cmp #$9b                    ;
    beq deathJumper             ; if (spike) then branch
    cmp #$9c                    ;
    beq deathJumper             ; if (spike) then branch
    cmp #$90                    ;
    beq keyCollisionFound       ; if (key) then branch
    cmp #$98                    ;
    beq switchCollisionFound    ; if (unswitched switch) then branch
    rts

; ***************************************************************************************
;
; checking an 'offscreen' background cache for spikes
;
; ***************************************************************************************
checkForLandingOnSpike
    lda #31                     ;
    jsr OSWRCH                  ;
    lda #$22                    ; TAB(34, 23)
    jsr OSWRCH                  ;
    lda #$17                    ;
    jsr OSWRCH                  ;

-
    lda #135                    ;
    jsr OSBYTE                  ; read character at cursor position
    cpx #0                      ;
    beq drawSpaces              ;
    cpx #$9b                    ;
    beq deathJumper             ; if (spike) then branch (die)
    cpx #$9c                    ;
    beq deathJumper             ; if (spike) then branch (die)

    lda #9                      ; forward space
backIntoSpaceLoop
    jsr OSWRCH                  ;
    lda vduTextCursorXPosition  ; read text cursor X position
    cmp #0                      ;
    bne -                       ; loop until we reach the end of the row (end of the cache)
    rts                         ;

; ***************************************************************************************
drawSpaces
    lda #$20                    ;
    jmp backIntoSpaceLoop       ;

; ***************************************************************************************
keyCollisionFound
    lda #charSPACE              ;
    jsr OSWRCH                  ;

    dec keysLeft                ;

    lda #8                      ;
    jsr OSWRCH                  ;
    lda vduTextCursorXPosition  ;
    sta textCursorX             ;
    lda vduTextCursorYPosition  ;
    sta textCursorY             ;

    lda #99                     ;
    jsr addToScore              ;
    jmp tabToOldCursorPositionAndReturn ;

; ***************************************************************************************
deathJumper
    jmp death                       ;

    !byte $ea, $ea                  ; [UNUSED]

switchCollisionFound
    jsr triggerSwitch               ; }
    sta textCursorX                 ; } record current position
    lda vduTextCursorYPosition      ; }
    sta textCursorY                 ; }

    ldx #0                          ; loop counter
-
    lda switchMessage,x                     ;
    jsr OSWRCH                              ;
    inx                                     ;
    cpx #switchMessageEnd - switchMessage   ;
    bne -                                   ;

    lda playerPixelX                        ;
    cmp #80                                 ;
    bcc tabToOldCursorPositionAndReturn     ;

    lda #1                                  ;
    sta kongBeastSwitchTriggered            ; mark switch as triggered

    ldx #0                                  ; loop counter
-
    lda switchMessage2,x                    ;
    jsr OSWRCH                              ;
    inx                                     ;
    cpx #switchMessage2End - switchMessage2 ;
    bne -                                   ;

    ; [inefficient]
    ldy #2                                                          ; loop twice
twiceLoop
    ldx #0                                                          ; loop counter
-
    lda switchClearCentreMessage,x                                  ;
    jsr OSWRCH                                                      ;
    inx                                                             ;
    cpx #switchClearCentreMessageEnd - switchClearCentreMessage     ;
    bne -                                                           ;
    dey                                                             ;
    bne twiceLoop                                                   ;

    ; don't draw regular kong any more
    lda #$60                        ; store opcode $60 'RTS'
    sta drawRegularKong             ;

tabToOldCursorPositionAndReturn
    lda #31                         ;
    jsr OSWRCH                      ;
    lda textCursorX                 ; TAB(X, Y)
    jsr OSWRCH                      ;
    lda textCursorY                 ;
    jmp OSWRCH                      ;

; ***************************************************************************************
isSupporting
    cmp #$95                        ;
    bcs +                           ;
    cmp #$5f                        ;
    beq +                           ;
    cmp #$80                        ;
    bcc notSupporting               ;
    cmp #$90                        ;
    bcs notSupporting               ;
+
    lda playerPixelY                ;
    sta playerHeightOnTakeOff       ;
    lda #1                          ; yes, is supporting
    rts                             ;

; ***************************************************************************************
notSupporting
    lda #0                          ; no, is not supporting
    rts                             ;

; ***************************************************************************************
isCrumbleBar
    cmp #$5f                        ;
    beq +                           ;
    cmp #$82                        ;
    bcc notCrumbleBar               ;
    cmp #$8a                        ;
    bcs notCrumbleBar               ;
+
    lda #1                          ;
    rts                             ;

; ***************************************************************************************
notCrumbleBar
    lda #0                          ;
    rts                             ;

; ***************************************************************************************
isConveyor
    cmp #$8b                        ; } (first conveyor character)
    bcc notConveyor                 ; }
    cmp #$8f                        ; } (last conveyor character + 1)
    bcs notConveyor                 ; } if (conveyor belt) then A=1 else A=0
    lda #1                          ; }
    rts                             ; }

; ***************************************************************************************
notConveyor
    lda #0                          ;
    rts                             ;

; ***************************************************************************************
checkUpdateConveyor
    lda jumpDirection               ;
    cmp #0                          ;
    bne updateConveyor              ;
    lda #1                          ;
    sta willyFalling                ;
    rts                             ;

; ***************************************************************************************
updateConveyor
    lda #31                         ; }
    jsr OSWRCH                      ; }
    lda playerPixelX                ; }
    lsr                             ; }
    lsr                             ; }
    jsr OSWRCH                      ; } TAB(playerX/4, playerY/8 + 2)
    lda playerPixelY                ; }
    lsr                             ; }
    lsr                             ; }
    lsr                             ; }
    clc                             ; }
    adc #2                          ; }
    jsr OSWRCH                      ; }
    jsr readTwoCharactersFromScreen ; read the two characters immediately lower on screen than the player

    lda screenCharacterA            ;
    jsr isConveyor                  ;
    cmp #1                          ;
    beq foundConveyor               ;

    lda screenCharacterB            ;
    jsr isConveyor                  ;
    cmp #1                          ;
    beq foundConveyor               ;
    rts                             ;

; ***************************************************************************************
foundConveyor
    lda #1                              ;
    sta willyJustLandedOnConveyor       ;
    lda jumpDirection                   ;
    sta willyDeltaX                     ;
    jmp checkForUpdatePlayerOnConveyor  ;

; ***************************************************************************************
handleJumping
    lda jumpPhase                   ;
    cmp #17                         ;
    bcc updatePlayerWhenJumping     ; if (jumping) then branch
    jmp updatePlayerWhenSupported   ; falling

; ***************************************************************************************
updatePlayerWhenJumping
    lda playerPixelY                ;
    and #7                          ;
    cmp #0                          ;
    beq checkForLanding             ;
    jmp updateJump                  ;

; ***************************************************************************************
checkForLanding
    lda #31                         ;
    jsr OSWRCH                      ;
    lda playerPixelX                ;
    lsr                             ;
    lsr                             ;
    jsr OSWRCH                      ; TAB(playerX/4, (playerY-2) / 8)
    lda playerPixelY                ;
    sec                             ;
    sbc #2                          ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    jsr OSWRCH                      ;

    jsr readTwoCharactersFromScreen

    lda screenCharacterA            ;
    cmp #$8f                        ;
    beq hitWall                     ; if (wall) then branch
    lda screenCharacterB            ;
    cmp #$8f                        ;
    beq hitWall                     ; if (wall) then branch
    jmp updateInAir                 ;

; ***************************************************************************************
hitWall
    lda jumpPhase                   ;
    cmp #9                          ;
    bcs updateInAir                 ;
    lda #17                         ;
    sec                             ;
    sbc jumpPhase                   ;
    sta jumpPhase                   ;
    lda #0                          ;
    sta jumpDirection               ;
updateInAir
    lda playerPixelY                ;
    and #7                          ;
    cmp #0                          ;
    bne updateJump                  ;
    lda jumpPhase                   ;
    cmp #8                          ;
    bcc updateJump                  ;

    lda #31                         ;
    jsr OSWRCH                      ;
    lda playerPixelX                ;
    lsr                             ;
    lsr                             ;
    jsr OSWRCH                      ; TAB(playerX/4, 2 + (playerY + 3)/8)
    lda playerPixelY                ;
    clc                             ;
    adc #3                          ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    clc                             ;
    adc #2                          ;
    jsr OSWRCH                      ;

    jsr readTwoCharactersFromScreen ;
    lda screenCharacterA            ;
    jsr isSupporting                ;
    cmp #1                          ;
    beq updatePlayerWhenSupported   ;

    lda screenCharacterB            ;
    jsr isSupporting                ;
    cmp #1                          ;
    beq updatePlayerWhenSupported   ;

updateJump
    lda jumpPhase                   ;
    clc                             ;
    adc #1                          ;
    sta jumpPhase                   ;

    ldy jumpPhase                   ;
    lda newPlayerPixelY             ;
    sec                             ;
    sbc jumpMovementArray - 1,y     ;
    sta newPlayerPixelY             ;

    lda newPlayerPixelX             ;
    clc                             ;
    adc jumpDirection               ;
    sta newPlayerPixelX             ;
    lda jumpDirection               ;
    sta willyDeltaX                 ;
    jmp checkIfBlockedLeftOrRight	;

; ***************************************************************************************
updatePlayerWhenSupported
    lda #0                          ;
    sta isJumping                   ;
    sta jumpPhase                   ;
    jsr updatePlayerAirAndDrawConveyor  ;
    jsr checkUpdateConveyor         ;
    jmp updatePlayer                ;

; ***************************************************************************************
checkWhatsLeftOfThePlayer
    lda #31                         ;
    jsr OSWRCH                      ;
    lda playerPixelX                ;
    lsr                             ;
    lsr                             ;
    sec                             ;
    sbc #1                          ;
    jsr OSWRCH                      ; TAB(playerX/4 - 1, (newPlayerPixelY + playerYNegativeOffsetWithinCell) / 8)
    lda newPlayerPixelY             ;
    clc                             ;
    adc playerYNegativeOffsetWithinCell ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    jsr OSWRCH                      ;
    jsr readTwoCharactersVertically ;

    lda newPlayerPixelY             ;
    and #7                          ;
    cmp #0                          ;
    beq +                           ;

    ; if we are not vertically aligned with a cell then we need to check another cell
    lda screenCharacterB            ;
    sta screenCharacterAPrime       ;
    lda #10                         ; VDU 10 (down)
    jsr OSWRCH                      ;
    jsr readTwoCharactersVertically ;

+
    lda screenCharacterAPrime       ;
    cmp #$20                        ;
    bne checkForCollisionToTheLeft  ; if (not a space) then branch (check for collision)

    lda screenCharacterB            ;
    cmp #$20                        ;
    bne checkForCollisionToTheLeft  ; if (not a space) then branch (check for collision)

    lda jumpPhase                   ;
    cmp #5                          ;
    bne checkForCollisionToTheLeft  ;
    rts                             ;

; ***************************************************************************************
checkForCollisionToTheLeft
    lda screenCharacterA            ;
    cmp #$8f                        ;
    beq markAsBlockedToTheLeft      ; if (wall) then branch

    lda screenCharacterB            ;
    cmp #$8f                        ;
    beq markAsBlockedToTheLeft      ; if (wall) then branch

    lda screenCharacterAPrime       ;
    cmp #$8f                        ;
    beq markAsBlockedToTheLeft      ; if (wall) then branch
    rts                             ;

; ***************************************************************************************
markAsBlockedToTheLeft
    lda #$fd                        ;
    sta willyDeltaX                 ;
    rts                             ;

; ***************************************************************************************
checkWhatsRightOfThePlayer
    lda #31                         ; }
    jsr OSWRCH                      ; }
    lda playerPixelX                ; }
    lsr                             ; }
    lsr                             ; }
    clc                             ; }
    adc #2                          ; }
    jsr OSWRCH                      ; } TAB(playerX/4 + 2, (newPlayerPixelY + playerYNegativeOffsetWithinCell)/8)
    lda newPlayerPixelY             ; }
    clc                             ; }
    adc playerYNegativeOffsetWithinCell ; }
    lsr                             ; }
    lsr                             ; }
    lsr                             ; }
    jsr OSWRCH                      ; }
    jsr readTwoCharactersVertically ;

    lda newPlayerPixelY             ;
    and #7                          ;
    cmp #0                          ;
    beq +                           ;

    ; if we are not vertically aligned with a cell then we need to check another cell
    lda screenCharacterB            ;
    sta screenCharacterAPrime       ;
    lda #10                         ; VDU 10 (down)
    jsr OSWRCH                      ;
    jsr readTwoCharactersVertically ;

+
    lda screenCharacterAPrime       ;
    cmp #$20                        ;
    bne checkForCollisionRight       ; if (not a space) then branch (check for collision)

    lda screenCharacterB            ;
    cmp #$20                        ;
    bne checkForCollisionRight       ; if (not a space) then branch (check for collision)

    lda jumpPhase                   ;
    cmp #5                          ;
    bne checkForCollisionRight      ;
    rts                             ;

; ***************************************************************************************
checkForCollisionRight
    lda screenCharacterA            ;
    cmp #$8f                        ;
    beq markAsBlockedToTheRight     ; if (wall) then branch

    lda screenCharacterB            ;
    cmp #$8f                        ;
    beq markAsBlockedToTheRight     ; if (wall) then branch

    lda screenCharacterAPrime       ;
    cmp #$8f                        ;
    beq markAsBlockedToTheRight     ; if (wall) then branch
    rts                             ;

; ***************************************************************************************
markAsBlockedToTheRight
    lda #$fe                        ;
    sta willyDeltaX                 ;
    rts                             ;

; ***************************************************************************************
updateWillyOnConveyor
    lda conveyorDirection           ;
    cmp #1                          ;
    bne updateConveyorMovement      ;
    lda willyAnimationEOR           ;
    cmp #3                          ;
    bne updateConveyorMovement      ;

    lda #>willyRight0               ; }
    sta willyGraphicsPage           ; }
    lda #0                          ; } look right
    sta willyAnimationEOR           ; }

    jmp checkIfBlockedLeftOrRight   ;

; ***************************************************************************************
updateConveyorMovement
    lda conveyorDirection           ;
    cmp #1                          ;
    bne +                           ;

    ; conveyor right
    lda conveyorDirection           ;
    sta willyDeltaX                 ;
    lda newPlayerPixelX             ;
    clc                             ;
    adc conveyorDirection           ;
    sta newPlayerPixelX             ;
    rts                             ;

; ***************************************************************************************
+
    lda conveyorDirection           ;
    cmp #$ff                        ;
    bne walkWithConveyor            ;

    ; conveyor left
    lda willyAnimationEOR           ;
    cmp #0                          ;
    bne walkWithConveyor            ;
    lda #>willyLeft0                ; }
    sta willyGraphicsPage           ; }
    lda #3                          ; } look left
    sta willyAnimationEOR           ; }
    jmp checkIfBlockedLeftOrRight   ;

; ***************************************************************************************
walkWithConveyor
    lda conveyorDirection           ;
    sta willyDeltaX                 ;
    lda newPlayerPixelX             ;
    clc                             ;
    adc conveyorDirection           ;
    sta newPlayerPixelX             ;
    rts                             ;

; ***************************************************************************************
playerPixelX
    !byte $18
playerPixelY
    !byte $20
newPlayerPixelX
    !byte $18
newPlayerPixelY
    !byte $20

willyDeltaX
    !byte $ea
willyAnimationEOR
    !byte $03                       ; 0 if pointing right; 3 if pointing left
willyGraphicsPage
    !byte $06
willyChangedDirection
    !byte $ea

willySpriteAddressLow
    !byte $00
willySpriteAddressHigh
    !byte $00

    !byte $00                       ; [UNUSED, but copied in and out of cache]
    !byte $00                       ; [UNUSED, but copied in and out of cache]

hasDrawnConveyors
    !byte $ea                       ;
willyFalling
    !byte $ea                       ;
willyJustLandedOnConveyor
    !byte $ea                       ;

    ; $1849
screenCharacterA
    !byte $ea                       ;
screenCharacterB
    !byte $ea                       ;

    ; $184b
isJumping
    !byte $ea                       ;
playerHeightOnTakeOff
    !byte $ea                       ;
jumpPhase
    !byte $ea                       ;
jumpDirection
    !byte $ea                       ;
spriteRowCounter
    !byte $ea                       ;

    ; $1850
playerXOffsetWithinCell
    !byte $ea                       ;
playerYNegativeOffsetWithinCell
    !byte $ea                       ;
willyIsOnConveyor
    !byte $ea                       ;
willyDirectionAgainstFlowOfConveyor
    !byte $ea                       ; $01 or $ff when moving against the flow of the conveyor

conveyorDirection
    !byte $ff                       ;


    !byte $ea                       ; [UNUSED]

    ; $1856
    ; vertical movements at each stage of a jump
jumpMovementArray
    !byte $04, $04, $03, $03, $02, $02, $01, $00, $00, $00, $ff, $fe, $fe, $fd, $fd, $fc, $fc

textCursorX
    !byte $00
textCursorY
    !byte $ea

    ; $1869
; ***************************************************************************************
;
; On Entry:
;   A = 0   means read from cache and write to screen
;   A = 1   means read from screen and write to cache
;   X = x pixel position
;   Y = Y pixel position
;
; ***************************************************************************************
readOrWriteCachedBackground
    stx $71                         ;
    sty $72                         ;
    sta $70                         ;
    txa                             ;
    and #$fc                        ;
    sta $71                         ;
    tya                             ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    sta $72                         ;
    lda #<logicalScreenStart        ; }
    sta readOrWriteScreen + 1       ; } start of screen address
    lda #>logicalScreenStart        ; }
    sta readOrWriteScreen + 2       ; }

    ldx #0                          ; loop counter
-
    lda readOrWriteScreen + 1       ; }
    clc                             ; }
    adc $71                         ; }
    sta readOrWriteScreen + 1       ; } add $71 to to screen address
    lda readOrWriteScreen + 2       ; } multiplication by repeated addition
    adc #0                          ; }
    sta readOrWriteScreen + 2       ; }
    inx                             ;
    cpx #4                          ; loop four times
    bne -                           ;

    ; $72 is the character row we want, we add $0280 for each row in a loop
    ldx #0                          ; loop counter
-
    cpx $72                         ;
    beq readOrWriteCachedBackgroundInternal ;
    lda readOrWriteScreen + 1       ; }
    clc                             ; } multiplication by repeated addition
    adc #$80                        ; }
    sta readOrWriteScreen + 1       ; } Add $0280 to screen address
    lda readOrWriteScreen + 2       ; }
    adc #2                          ; }
    sta readOrWriteScreen + 2       ; }
    inx                             ;
    jmp -                           ;

; ***************************************************************************************
;
; On Entry:
;   $70 = 0   means read from cache and write to screen
;   $70 = 1   means read from screen and write to cache
;
; ***************************************************************************************
readOrWriteCachedBackgroundInternal
    ; set up for reading from the screen and writing to the background cache
    lda #<readScreenWriteCache              ; }
    sta readWriteBackgroundCacheLoop + 1    ; } address of the routine to call to copy a byte
    lda #>readScreenWriteCache              ; }
    sta readWriteBackgroundCacheLoop + 2    ; }

    lda #$bd                                ; store opcode for LDA abs,X
    sta readOrWriteScreen                   ;

    lda #$99                                ; store opcode for STA abs,Y
    sta readOrWriteCache                    ;

    ; test which direction we want to read/write
    lda $70                                 ;
    cmp #1                                  ;
    beq +                                   ;

    ; set up for reading from the background cache and writing to the screen
    lda #<readCacheWriteScreen              ; }
    sta readWriteBackgroundCacheLoop + 1    ; } address of the routine to call to copy a byte
    lda #>readCacheWriteScreen              ; }
    sta readWriteBackgroundCacheLoop + 2    ; }

    lda #$9d                        ; } store opcode for STA abs,X
    sta readOrWriteScreen           ; }

    lda #$b9                        ; } store opcode for LDA abs,Y
    sta readOrWriteCache            ; }

+
    lda #32                         ;
    sta cacheLoopXLimit             ; copy two character columns by default

    lda willyIsOnConveyor           ;
    cmp #1                          ;
    beq copyCache                   ;
    lda switchTriggered             ;
    cmp #1                          ;
    beq copyCache                   ;

    lda willyChangedDirection       ;
    cmp #0                          ; [redundant]
    bne copyCache                   ;

    lda $70                         ;
    cmp #0                          ; [redundant]
    bne copyCache                   ;

    lda playerPixelX                ;
    and #3                          ;
    eor willyAnimationEOR           ;
    cmp #0                          ;
    bne copyCache                   ;
    lda willyAnimationEOR           ;
    cmp #3                          ;
    beq copyCache1x1                ;
    lda #16                         ;
    sta cacheLoopXLimit             ; copy one character column
    jmp copyCache                   ;

; ***************************************************************************************
copyCache1x1
    ldx #16                             ;
    ldy #16                             ;
    lda #16                             ;
    sta cacheGotoNextRow + 1            ; copy 1x1 characters
    jmp readWriteBackgroundCacheLoop    ;

; ***************************************************************************************
copyCache
    ldx #0                              ; inner loop counter (within one row)
    ldy #0                              ; outer loop counter (number of rows * 32)
    stx cacheGotoNextRow + 1            ; copy two by two characters worth
readWriteBackgroundCacheLoop
    jsr $ffff                           ;
    inx                                 ;
    iny                                 ;
cacheLoopXLimit = * + 1
    cpx #32                             ;
    bne readWriteBackgroundCacheLoop    ;
    lda cacheGotoNextRow + 1            ;
    cmp #16                             ;
    beq +                               ;
    lda cacheLoopXLimit                 ;
    cmp #32                             ;
    beq cacheGotoNextRow                ; if (copying two columns) then branch
+
    tya                                 ; }
    clc                                 ; }
    adc #16                             ; } Y += 16
    tay                                 ; }

cacheGotoNextRow
    ldx #0                              ;

    lda readOrWriteScreen + 1           ; }
    clc                                 ; }
    adc #$80                            ; }
    sta readOrWriteScreen + 1           ; } add $0280 to screen address (goto next row)
    lda readOrWriteScreen + 2           ; }
    adc #$02                            ; }
    sta readOrWriteScreen + 2           ; }

    cpy #95                             ;
    bcc readWriteBackgroundCacheLoop    ; if (Y < 95) then branch (loop back)
    lda #0                              ;
    sta switchTriggered                 ;
    rts                                 ;

; ***************************************************************************************
readOrWriteScreen
    lda logicalScreenStart,x            ; screen address
    rts                                 ;

; ***************************************************************************************
readOrWriteCache
    lda backgroundCache,y               ; off-the-visible-screen storage area
    rts                                 ;

; ***************************************************************************************
readCacheWriteScreen
    jsr readOrWriteCache                ; read cache
    jmp readOrWriteScreen               ; write to screen

; ***************************************************************************************
readScreenWriteCache
    jsr readOrWriteScreen               ; read screen
    jmp readOrWriteCache                ; write cache

    !byte $00                           ; [UNUSED]

    ; $197f
kongBeastSwitchTriggered
    !byte $00                           ;

; ***************************************************************************************
updateVerticalGuardians
    lda currentLevel                    ;
    cmp #5                              ;
    beq drawEugene                      ;
    cmp #8                              ;
    beq drawRegularKong                 ;
    cmp #12                             ;
    beq drawRegularKong                 ; if (level 8 or 12) then branch (draw Kong)
    cmp #9                              ;
    beq drawVerticalGuardiansJumper     ;
    cmp #16                             ;
    beq +                               ; if (level 16) then branch (return)
    cmp #11                             ;
    bcs drawVerticalGuardiansJumper     ;
+
    rts                                 ;

; ***************************************************************************************
drawVerticalGuardiansJumper
    jmp drawVerticalGuardians

; ***************************************************************************************
drawEugene
eugeneColourMask = * + 1
    lda #$f0                            ;
    sta spriteColourMask                ; colour 2
    lda eugenePositionY                 ;
    and #$7f                            ;
    cmp #$60                            ; bottom coordinate
    beq toggleEugeneDirection           ;
    cmp #8                              ;
    beq toggleEugeneDirection           ; top coordinate
moveEugene
    lda eugenePositionY                 ;
    and #$80                            ;
    cmp #$80                            ;
    bne moveEugeneDown                  ;

    ; move Eugene up
    inc eugenePositionY                 ;
    jmp +                               ;

; ***************************************************************************************
moveEugeneDown
    dec eugenePositionY                 ;
+
    ldx #$4c                            ;
    lda eugenePositionY                 ;
    and #$7f                            ;
    tay                                 ;
    jsr setEugineSprite                 ;
    lda #3                              ;
    jmp plot                            ; plot Eugene (mode 3)

; ***************************************************************************************
setEugineSprite
    lda #<verticalGuardianMODE1Address  ; }
    sta plotSourceSpriteAddressLow      ; } address verticalGuardianMODE1Address
    lda #>verticalGuardianMODE1Address  ; }
    sta plotSourceSpriteAddressHigh     ; }

    lda #0                              ; }
    sta $79                             ; }
    lda #$2f                            ; } $2f00 (?)
    sta $7a                             ; }
    rts                                 ;

; ***************************************************************************************
toggleEugeneDirection
    lda eugenePositionY                 ;
    eor #$80                            ;
    sta eugenePositionY                 ;
doWeMoveEugene
    jmp moveEugene                      ;

; ***************************************************************************************
drawRegularKong
    lda #$f0                            ;
    sta spriteColourMask                ; colour 2

    inc kongAnimationCounter            ;
    lda kongAnimationCounter            ;
    and #8                              ;
    cmp #8                              ;
    beq showKongAnimationState1         ;
    lda #<verticalGuardianMODE1Address  ; }
    sta plotSourceSpriteAddressLow      ; }
    lda #>verticalGuardianMODE1Address  ; } address of Kong animation 0
    sta plotSourceSpriteAddressHigh     ; }
    jmp +                               ;

; ***************************************************************************************
showKongAnimationState1
    lda #<verticalGuardianMODE1Address1 ; }
    sta plotSourceSpriteAddressLow      ; } address of Kong animation 1
    lda #>verticalGuardianMODE1Address1 ; }
    sta plotSourceSpriteAddressHigh     ; }
+
    ldx #78                             ;
    ldy #8                              ;
    lda #3                              ;
    jmp plot                            ; draw Kong (mode 3)

; ***************************************************************************************
return7
    rts                                 ;

; ***************************************************************************************
drawLevel19VerticalGuardians
    lda #4                              ;
    sta drawGuardianPlotType            ;
    lda #5                              ;
    sta verticalGuardiansPlotType       ;
    jmp drawRegularVerticalGuardians    ;

; ***************************************************************************************
drawVerticalGuardians
    lda currentLevel                    ;
    cmp #19                             ;
    beq drawLevel19VerticalGuardians    ;
    lda #2                              ;
    sta verticalGuardiansPlotType       ;
    lda #3                              ;
    sta drawGuardianPlotType            ;

drawRegularVerticalGuardians
    inc verticalAnimationCounter        ;
    lda verticalAnimationCounter        ;
    and #3                              ;
    sta eugenePositionY                 ; animation state: here 'eugenePositionY' used as temporary storage
    ldx #0                              ;
    lda #<verticalGuardianMODE1Address  ; }
    sta tempGuardianSpriteAddrLow       ; } address of vertical guardian sprite
    lda #>verticalGuardianMODE1Address  ; }
    sta tempGuardianSpriteAddrHigh      ; }
-
    cpx eugenePositionY                 ; animation state: here 'eugenePositionY' used as temporary storage
    beq gotSpriteAddress                ; multiplication by repeated addition
    inx                                 ;
    lda tempGuardianSpriteAddrLow       ; }
    clc                                 ; }
    adc #$40                            ; } increment by $40
    sta tempGuardianSpriteAddrLow       ; }
    jmp -                               ;

; ***************************************************************************************
gotSpriteAddress
    lda currentLevel                    ;
    cmp #14                             ;
    bne +                               ;

    ; level 14 specific code
    lda #0                              ;
    sta tempGuardianSpriteAddrLow       ;

+
    lda #0                              ;
    sta currentGuardianColour           ;
    ldx #0                              ;
    stx currentGuardianIndex            ;

updateOneVerticalGuardian
    lda currentVerticalGuardians,x      ;
    cmp #$ff                            ;
    beq return7                         ;
    sta currentGuardianX                ; x coordinate + top bit for direction + bit 6 for speed
    inx                                 ;
    jsr readByteFromVerticalGuardians   ;
    sta currentGuardianY                ; y coordinate
    inx                                 ;
    jsr readByteFromVerticalGuardians   ;
    sta currentGuardianExtent1          ; Y extent 1
    inx                                 ;
    jsr readByteFromVerticalGuardians   ;
    sta currentGuardianExtent2          ; Y extent 2
    stx currentGuardianIndex            ;
    lda currentGuardianX                ;
    and #$40                            ;
    cmp #$40                            ;
    beq fastGuardian                    ;
    lda #2                              ; set slow speed
    jmp +                               ;

; ***************************************************************************************
fastGuardian
    lda #4                      ; set fast speed
+
    sta currentGuardianSpeed    ;
    lda currentGuardianColour   ;
    and #3                      ;
    tax                         ;
    lda guardianColourMasks,x   ;
    sta spriteColourMask        ; set sprite colour
    lda currentGuardianExtent1  ;
    and #$80                    ;
    cmp #$80                    ;
    bne updateGuardian          ;
    jmp drawSkylabCrashing      ;

; ***************************************************************************************
updateGuardian
    lda currentLevel            ;
    cmp #19                     ;
    bne +                       ; if (not level 19) then branch
    lda spriteColourMask        ;
    cmp #$ff                    ;
    bne +                       ; if (not colour 3) then branch
    lda #$f0                    ; make the meteors in the Meteor Storm colour 2
    sta spriteColourMask        ;
+
    lda currentGuardianX        ;
    and #$3f                    ;
    asl                         ;
    asl                         ;
    clc                         ;
    adc #$10                    ;
    tax                         ;
    lda currentGuardianY        ;
    clc                         ;
    adc #8                      ;
    tay                         ;
verticalGuardiansPlotType = * + 1
    lda #5                      ;
    jsr plot                    ; draw vertical guardian (mode 5)
    lda currentGuardianX        ; }
    and #$80                    ; } check current direction
    cmp #$80                    ; }
    beq moveGuardianDown        ; if (down) then branch

    ; move guardian up
    lda currentGuardianY        ;
    sec                         ;
    sbc currentGuardianSpeed    ;
    sta currentGuardianY        ;
    jmp drawVerticalGuardian    ;

; ***************************************************************************************
moveGuardianDown
    lda currentGuardianY        ;
    clc                         ;
    adc currentGuardianSpeed    ;
    sta currentGuardianY        ;

drawVerticalGuardian
    lda currentGuardianX        ;
    and #$3f                    ;
    asl                         ;
    asl                         ;
    clc                         ;
    adc #$10                    ;
    tax                         ; X = (guardianX * 4) + 16
    lda currentGuardianY            ;
    clc                             ;
    adc #8                          ;
    tay                             ; Y = (guardianY + 8)
    lda tempGuardianSpriteAddrLow   ;
    sta plotSourceSpriteAddressLow  ;
    lda tempGuardianSpriteAddrHigh  ;
    sta plotSourceSpriteAddressHigh ;
drawGuardianPlotType = * + 1
    lda #4                      ;
    jsr plot                    ; draw vertical guardian (mode 4)

    lda currentGuardianY        ;
    cmp currentGuardianExtent1  ;
    beq bounceCurrentGuardian   ;
    cmp currentGuardianExtent2  ;
    beq bounceCurrentGuardian   ;

updateCurrentGuardian
    ldx currentGuardianIndex            ;
    dex                                 ;
    dex                                 ;
    dex                                 ;
    lda currentGuardianX                ;
    jsr writeByteToVerticalGuardians    ;
    inx                                 ;
    lda currentGuardianY                ;
    jsr writeByteToVerticalGuardians    ;
    inx                                 ;
    lda currentGuardianExtent1          ;
    jsr writeByteToVerticalGuardians    ;
    inx                                 ;
    lda currentGuardianExtent2          ;
    jsr writeByteToVerticalGuardians    ;
    inx                                 ;
    stx currentGuardianIndex            ;
    lda currentGuardianColour           ;
    clc                                 ;
    adc #1                              ;
    and #3                              ;
    sta currentGuardianColour           ;
    cpx #$10                            ;
    beq return11                        ;
    jmp updateOneVerticalGuardian       ;

; ***************************************************************************************
return11
    rts                             ;

; ***************************************************************************************
bounceCurrentGuardian
    lda currentLevel                ;
    cmp #14                         ;
    beq crashLand                   ; if (skylab landing bay) then don't bounce, crash land
    lda currentGuardianX            ; }
    eor #$80                        ; } flip direction
    sta currentGuardianX            ; }
    jmp updateCurrentGuardian       ;

; ***************************************************************************************
crashLand
    lda currentGuardianExtent1      ;
    eor #$80                        ;
    sta currentGuardianExtent1      ;
    jsr guardianGetAnimationIndex   ;
    lda #0                          ;
    sta guardianSpriteOffsets,y     ;
    jmp updateCurrentGuardian       ;

; ***************************************************************************************
drawSkylabCrashing
    jsr guardianGetAnimationIndex   ;
    lda guardianSpriteOffsets,y     ; }
    clc                             ; }
    adc #1                          ; } add one to sprite offsets
    sta guardianSpriteOffsets,y     ; }
    asl                             ;
    asl                             ;
    asl                             ;
    asl                             ;
    asl                             ;
    asl                             ;
    sta plotSourceSpriteAddressLow  ; set source address (low) to 64 * spriteOffset
    sty tempGuardianSpriteOffset    ;
    jsr getSkylabSprite             ;
    lda currentGuardianX            ;
    and #$3f                        ;
    asl                             ;
    asl                             ;
    clc                             ;
    adc #$10                        ;
    tax                             ;
    lda currentGuardianY            ;
    clc                             ;
    adc #8                          ;
    tay                             ;
    lda #3                          ;
    jsr plot                        ; draw Skylab crashing (mode 3)
    ldy tempGuardianSpriteOffset    ;
    lda guardianSpriteOffsets,y     ;
    cmp #6                          ;
    beq finishedCrashingSkylab      ;
    jmp updateCurrentGuardian       ;

; ***************************************************************************************
finishedCrashingSkylab
    lda #0                          ;
    sta currentGuardianY            ;
    lda currentGuardianExtent1      ;
    eor #$80                        ;
    sta currentGuardianExtent1      ;
    lda currentGuardianX            ;
    ora #$80                        ;
    clc                             ;
    adc #8                          ;
    sta currentGuardianX            ;
    and #$3f                        ;
    cmp #$20                        ;
    bcs guardianXTooBig             ;
    jmp updateCurrentGuardian       ;

; ***************************************************************************************
guardianGetAnimationIndex
    lda currentGuardianY            ;
    cmp #$48                        ;
    beq setYZero                    ;
    cmp #$38                        ;
    beq setYOne                     ;

    ldy #2                          ;
    rts                             ;

; ***************************************************************************************
setYZero
    ldy #0                          ;
    rts                             ;

; ***************************************************************************************
setYOne
    ldy #1                          ;
    rts                             ;

; ***************************************************************************************
guardianXTooBig
    lda currentGuardianX            ;
    sec                             ;
    sbc #$20                        ;
    sta currentGuardianX            ;
    jmp updateCurrentGuardian       ;

; ***************************************************************************************
getSkylabSprite
    jsr guardianGetAnimationIndex   ;
    lda guardianSpriteOffsets,y     ;
    cmp #4                          ;
    beq setSkylabSprite4            ;
    cmp #5                          ;
    beq setSkylabSprite5            ;
    cmp #6                          ;
    beq setSkylabSprite6            ;
    lda #>verticalGuardianMODE1Address  ;
    sta plotSourceSpriteAddressHigh     ;
    rts                                 ;

; ***************************************************************************************
setSkylabSprite4
    lda #<skylab4Sprite             ;
    sta plotSourceSpriteAddressLow  ; set sprite address
    lda #>skylab4Sprite             ;
    sta plotSourceSpriteAddressHigh ;
    rts                             ;

; ***************************************************************************************
setSkylabSprite5
    lda #<skylab5Sprite             ;
    sta plotSourceSpriteAddressLow  ; set sprite address
    lda #>skylab5Sprite             ;
    sta plotSourceSpriteAddressHigh ;
    rts                             ;

; ***************************************************************************************
setSkylabSprite6
    lda #<blankAreaOfScreen         ;
    sta plotSourceSpriteAddressLow  ; set sprite address (area to the right of screen that is blank)
    lda #>blankAreaOfScreen         ;
    sta plotSourceSpriteAddressHigh ;
    rts                             ;

; ***************************************************************************************
    ; $1c48
eugenePositionY
    !byte $ea                       ; top bit indicates current direction
kongAnimationCounter
    !byte $ea
verticalAnimationCounter
    !byte $ea                       ; animation for vertical guardinas

currentGuardianX
    !byte $ea                       ;
currentGuardianY
    !byte $ea                       ;
currentGuardianExtent1
    !byte $ea                       ;
currentGuardianExtent2
    !byte $ea                       ;
currentGuardianIndex
    !byte $ea

    ; $1c50
tempGuardianSpriteOffset
    !byte $ea                       ;
guardianSpriteOffsets
    !byte $ea, $ea, $ea             ;
tempGuardianSpriteAddrLow
    !byte $ea                       ;
tempGuardianSpriteAddrHigh
    !byte $ea                       ;

    !byte $ea                       ; [UNUSED]

currentGuardianSpeed
    !byte $ea                       ;

; ***************************************************************************************
copyEugeneIntoMODE1Format
    ldy #0                              ; loop counter
    lda #<verticalGuardianMODE1Address  ; }
    sta storeByte + 1                   ; }
!if (<verticalGuardianMODE1Address) != 0 {
    !error "vertical guardian address should be on a page boundary"
}
    sta copyEugeneByteCounter           ; }
    lda #>verticalGuardianMODE1Address  ; }
    sta storeByte + 2                   ; }

-
    ldx copyEugeneByteCounter       ;
specialSpriteSourceAddress = * + 1
    lda eugeneSprite,x              ;
    sta copyEugeneSourceByte        ; store source byte
    stx copyEugeneByteCounter       ; [redundant]
    and #$f0                        ; top nybble
    sta copyEugeneTempByte          ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    lsr                             ; shift to lower nybble
    clc                             ;
    adc copyEugeneTempByte          ; add original to get a Eugene in colour 3

    jsr storeByte                   ;

    lda copyEugeneSourceByte        ; recall source byte
    and #$0f                        ; lower nybble
    sta copyEugeneTempByte          ;
    asl                             ;
    asl                             ;
    asl                             ;
    asl                             ;
    clc                             ;
    adc copyEugeneTempByte          ; add lower byte to get white Eugene in colour 3
    sta copyEugeneTempByte          ; store
    tya                             ; }
    clc                             ; } Y += 8
    adc #8                          ; }
    tay                             ; }
    lda copyEugeneTempByte          ;
    jsr storeByte                   ; store right hand side byte of Eugene
    ldx copyEugeneByteCounter       ;
    inx                             ; increment source counter
    stx copyEugeneByteCounter       ;
    tya                             ; }
    sec                             ; }
    sbc #7                          ; } Y -= 7
    tay                             ; }
    cmp #8                          ;
    bne -                           ; loop 8 times
    ldy #$00                        ; reset loop counter
    lda storeByte + 1               ;
    clc                             ;
    adc #$10                        ; add 16 to destination byte
    sta storeByte + 1               ;
    ldx copyEugeneByteCounter       ;
    cpx #$80                        ; check if we are done
    bne -                           ; if (not done) then branch (loop back)
    rts                             ;

; ***************************************************************************************
storeByte
    sta $ffff,y                     ;
    rts                             ;

copyEugeneSourceByte
    !byte $ea                       ;
copyEugeneTempByte
copyWhichSprite
    !byte $ea                       ;
copyEugeneByteCounter
    !byte $ea                       ;

; ***************************************************************************************
levelWithKongBeast
    lda #2                          ;
    sta copyWhichSprite             ; copy Kong
    jmp continueCopySprites         ;

; ***************************************************************************************
levelWithAmoebatrons
    lda #9                          ;
    sta copyWhichSprite             ; copy Amoebatrons
    jmp continueCopySprites         ;

; ***************************************************************************************
levelEugenesLair
    lda #1                          ;
    sta copyWhichSprite             ; copy Eugene
    lda #8                          ;
    sta eugenePositionY             ;
    jmp continueCopySprites         ;

; ***************************************************************************************
copyVerticalSprites
    lda #0                              ;
    sta verticalAnimationCounter        ;
    lda #>eugeneSprite                  ;
    sta specialSpriteSourceAddress + 1  ;
    lda #<eugeneSprite                  ;
    sta specialSpriteSourceAddress      ; default to copying Eugene
    lda currentLevel                    ;
    cmp #12                             ;
    beq levelWithKongBeast              ;
    cmp #8                              ;
    beq levelWithKongBeast              ;
    cmp #9                              ;
    beq levelWithAmoebatrons            ;
    cmp #5                              ;
    beq levelEugenesLair                ;
    lda currentLevel                    ;
    sec                                 ;
    sbc #10                             ;
    tax                                 ;
    lda verticalGuardiansSpritesArray,x ;
    sta copyWhichSprite                 ; copy based on level number - 10
continueCopySprites
    ldx #1                              ;

-
    cpx copyWhichSprite                 ; multiplication by repeated addition
    beq foundSprite                     ;

    lda specialSpriteSourceAddress      ; }
    clc                                 ; }
    adc #$80                            ; }
    sta specialSpriteSourceAddress      ; } add $80 to address
    lda specialSpriteSourceAddress + 1  ; }
    adc #0                              ; }
    sta specialSpriteSourceAddress + 1  ; }

    inx                                 ;
    jmp -                               ;

; ***************************************************************************************
return4
    rts                                 ;

; ***************************************************************************************
foundSprite
    jsr copyEugeneIntoMODE1Format       ;
    lda currentLevel                    ;
    cmp #9                              ; Levels 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    beq handleVerticalGuardians         ; have vertical guardians
    cmp #11                             ;
    bcc return4                         ; if (currentLevel < 11) then branch (return)

handleVerticalGuardians
    ldx #8                              ;
    lda #0                              ;
-
    clc                                 ;
    adc #8                              ; multiplication by repeated addition
    inx                                 ;
    cpx currentLevel                    ;
    bne -                               ;

    clc                                 ;
    adc #<verticalGuardians             ;
    sta readVerticalGuardiansByte + 1   ; addr = verticalGuardians + 8 * (currentLevel-8)

    ldx #0                              ; loop counter
    ldy #0                              ;
-
    jsr readVerticalGuardiansByte       ;
    cmp #$ff                            ;
    beq finishUpVerticalGuardians       ; if (terminator) then branch
    sta currentVerticalGuardians,y      ; write x coordinate of vertical guardian. top bit is direction (clear = up, set = down)
    iny                                 ;
    inx                                 ;
    jsr readVerticalGuardiansByte       ;
    sta currentVerticalGuardians,y      ; write byte 1: copy byte 1
    iny                                 ;
    sta currentVerticalGuardians,y      ; write byte 2: copy byte 1
    iny                                 ;
    sta currentVerticalGuardians,y      ; write byte 3: copy byte 1

    lda currentVerticalGuardians,y      ; [redundant]
    and #$0f                            ;
    asl                                 ;
    asl                                 ;
    asl                                 ;
    sta currentVerticalGuardians,y      ; write first extent (bottom nybble of byte 1 multiplied by eight)

    dey                                 ;
    lda currentVerticalGuardians,y      ;
    and #$f0                            ;
    lsr                                 ;
    sta currentVerticalGuardians,y      ; write second extent (top nybble of byte 1 divided by two)

    dey                                 ;
    sta currentVerticalGuardians,y      ; write y coordinate (top nybble of byte 1 divided by two)
    iny                                 ;
    iny                                 ;
    iny                                 ; Y is effectively moved on four bytes in aggregate
    inx                                 ;
    cpx #8                              ; loop eight times
    bne -                               ;
    rts                                 ;

; ***************************************************************************************
finishUpVerticalGuardians
    sta currentVerticalGuardians,y      ;
    rts                                 ;

; ***************************************************************************************
currentGuardianColour
    !byte $ea                           ;

; ***************************************************************************************
readVerticalGuardiansByte
    lda verticalGuardians + 8,x         ;
    rts                                 ;

; ***************************************************************************************
readByteFromVerticalGuardians
    lda currentVerticalGuardians,x      ;
    rts                                 ;

; ***************************************************************************************
writeByteToVerticalGuardians
    sta currentVerticalGuardians,x      ;
    rts                                 ;

; ***************************************************************************************
verticalGuardiansSpritesArray
    ; vertical guardians for the later levels
    ; Level     11,  12,  13,  14,  15,  16,  17,  18,  19,  20
    !byte $ea, $03, $00, $04, $05, $06, $00, $07, $0a, $08, $04

    ; Each vertical guardian has four bytes in this table
    ; <x coord + top bit for direction + bit 6 for speed>, <y coord>, <Y extent 1>, <Y extent 2>
currentVerticalGuardians
    !byte $ea, $ea, $ea, $ea            ; first  guardian
verticalGuardian2
    !byte $ea, $ea, $ea, $ea            ; second guardian
    !byte $ea, $ea, $ea, $ea            ; third  guardian
    !byte $ea, $ea, $ea, $ea            ; fourth guardian
guardianColourMasks
    !byte $f0, $ff, $0f, $f0

energyFieldSprites
    !byte %########
    !byte %.##..##.
    !byte %........
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %........
    !byte %.##..##.
    !byte %########

    !byte %########
    !byte %.##..##.
    !byte %........
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %.#....#.
    !byte %..#..#..
    !byte %........
    !byte %.##..##.
    !byte %########

    ; [UNUSED]
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $49

; ***************************************************************************************
swapBackPages
    jmp swapPagesC00andE00          ;

; ***************************************************************************************
readGuardianByte
    lda $2280,x                     ; [address is overwritten before use]
    rts                             ;

; ***************************************************************************************
updateLevel19Guardians
    jsr updateHorizontalGuardians   ;
    jmp updateLevel19Special        ;

; ***************************************************************************************
animateKeysUpdateHorizontalGuardiansAndLevel19EnergyFields
    nop                             ;
    nop                             ;
    nop                             ;

    jsr colourCycleKeys             ;

    lda #17                         ;
    jsr OSWRCH                      ;
    lda #3                          ; COLOUR 3
    jsr OSWRCH                      ;

    lda currentLevel                ;
    cmp #19                         ;
    beq updateLevel19Guardians      ; if (level 19) then branch (update guardians and energy fields)
    jmp updateHorizontalGuardians   ; [redundant]


; ***************************************************************************************
updateHorizontalGuardians
    jsr swapPagesC00andE00          ; swap in guardian definitions
    lda #0                          ;
    sta drawGuardianLoopCounter     ;
    tay                             ;
    tax                             ;

drawGuardiansLoop
    lda guardianPositions,y         ; }
    sta zpGuardianPositionX,x       ; }
    iny                             ; } copy guardian info to zero page cache
    inx                             ; } from guardianPositions to $8a for four bytes
    cpx #4                          ; }
    bne drawGuardiansLoop           ; }

    lda zpGuardianPositionX         ;
    cmp #$ff                        ;
    beq swapBackPages               ; if (end of guardian array) then branch (finish up)

    jsr updateAndDrawGuardian       ; update and draw guardian

    lda drawGuardianLoopCounter     ;
    clc                             ;
    rol                             ;
    rol                             ;
    tay                             ; Y = 4 * loop counter
    ldx #0                          ; loop counter

-
    lda zpGuardianPositionX,x       ; }
    sta guardianPositions,y         ; }
    inx                             ; } copy guardian info back from zero page cache
    iny                             ; } from $8a to guardianPositions for four bytes
    cpx #4                          ; }
    bne -                           ; }

    inc drawGuardianLoopCounter     ;

    lda #17                         ;
    jsr OSWRCH                      ; COLOUR

    lda drawGuardianLoopCounter     ;
    and #3                          ;
    tax                             ;
    lda guardianColourTable,x       ;
    jsr OSWRCH                      ; set colour

    lda drawGuardianLoopCounter     ;
    clc                             ;
    rol                             ;
    rol                             ;
    tay                             ;
    ldx #0                          ;
    jmp drawGuardiansLoop           ;

; ***************************************************************************************
updateAndDrawGuardian
    lda zpGuardianPositionY         ;
    eor #$40                        ; flip bit 6
    sta zpGuardianPositionY         ;

    tay                             ;
    and #$20                        ;
    cmp #$20                        ;
    bne moveLeftOrRight             ; if (bit 5 clear) then branch
    tya                             ;
    and #$40                        ;
    cmp #$40                        ;
    beq moveLeftOrRight             ; if (bit 6 set) then branch
    rts                             ;

; ***************************************************************************************
moveLeftOrRight
    lda zpGuardianPositionY         ;
    and #$80                        ;
    cmp #$80                        ;
    bne moveGuardianLeft            ;

    ; move guardian right
    lda zpGuardianPositionX         ;
    clc                             ;
    adc #1                          ;
    and #$7f                        ;
    sta currentGuardianXPosition    ;

    lda zpGuardianPositionX         ;
    and #3                          ;
    asl                             ;
    sta zpGuardianAnimIndex         ; temp = 2 * (guardianX and 3)
    jsr positionCursorAtGuardian    ;
    lda zpGuardianAnimIndex         ;
    cmp #0                          ;
    bne notAtCellXBoundary          ;
    jsr eraseLeftOfGuardian         ;
    jsr positionCursorAtGuardian    ;

notAtCellXBoundary
    ; draw e0+temp, e1+temp
    ;      e8+temp, e9+temp
    lda #$e0                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    lda #$e1                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    lda #$0a                        ;
    jsr OSWRCH                      ; down one
    lda #8                          ;
    jsr OSWRCH                      ; back two
    jsr OSWRCH                      ;

    lda #$e8                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    lda #$e9                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    jmp testForBounceHorizontal     ;

; ***************************************************************************************
setAnimIndexBasedOnX
    lda zpGuardianPositionX         ;
    and #3                          ;
    asl                             ;
    sta zpGuardianAnimIndex         ;
    jmp notAtCellXBoundary          ;

; ***************************************************************************************
moveGuardianLeft
    lda zpGuardianPositionX         ;
    sec                             ;
    sbc #1                          ;
    and #$7f                        ;
    sta currentGuardianXPosition    ;
    lda zpGuardianPositionX         ;
    and #3                          ;
    eor #3                          ;
    asl                             ;
    sta zpGuardianAnimIndex         ;
    jsr positionCursorAtGuardian    ;
    lda zpGuardianAnimIndex         ;
    cmp #0                          ;
    bne +                           ;
    jsr eraseRightOfGuardian        ;
    jsr positionCursorAtGuardian    ;

+
    lda currentLevel                ;
    cmp #19                         ;
    beq setAnimIndexBasedOnX        ;
    cmp #15                         ;
    beq setAnimIndexBasedOnX        ;

    ; draw f1+temp, f0+temp
    ;      f+temp9, f8+temp
    lda #$f1                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;
    lda #$f0                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    lda #8                          ;
    jsr OSWRCH                      ; move back two places
    jsr OSWRCH                      ; and down one
    lda #$0a                        ;
    jsr OSWRCH                      ;

    lda #$f9                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    lda #$f8                        ;
    clc                             ;
    adc zpGuardianAnimIndex         ;
    jsr drawIfNotOverExit           ;

    jmp testForBounceHorizontal     ;

; ***************************************************************************************
positionCursorAtGuardian
    lda #31                         ;
    jsr OSWRCH                      ;
    lda zpGuardianPositionX         ;
    and #$fc                        ;
    clc                             ;
    ror                             ;
    ror                             ; TAB($8a/4 + 5, ($8b AND $0f) + 1)
    clc                             ;
    adc #5                          ;
    jsr OSWRCH                      ;
    lda zpGuardianPositionY         ;
    and #$0f                        ;
    clc                             ;
    adc #1                          ;
    jmp OSWRCH                      ;

; ***************************************************************************************
eraseLeftOfGuardian
    lda #8                          ;
    jsr OSWRCH                      ;
    lda #$20                        ;
    jsr drawIfNotOverExit           ;
    lda #$0a                        ;
    jsr OSWRCH                      ;
    lda #8                          ;
    jsr OSWRCH                      ;
    lda #$20                        ;
    jsr drawIfNotOverExit           ;
    rts

; ***************************************************************************************
eraseRightOfGuardian
    lda #9                          ;
    jsr OSWRCH                      ;
    jsr OSWRCH                      ; move forward two characters

    lda #$20                        ;
    jsr drawIfNotOverExit           ;

    lda #$0a                        ; down
    jsr OSWRCH                      ;
    lda #8                          ; left
    jsr OSWRCH                      ;

    lda #$20                        ;
    jsr drawIfNotOverExit           ;
    rts                             ;

; ***************************************************************************************
toggleGuardianDirection
    lda zpGuardianPositionY         ;
    eor #$80                        ; toggle direction
    sta zpGuardianPositionY         ;
    rts                             ;

; ***************************************************************************************
currentGuardianXPosition
    !byte $ea                       ;
drawGuardianLoopCounter
    !byte $ea                       ;

; ***************************************************************************************
testForBounceHorizontal
    lda currentGuardianXPosition    ;
    sta zpGuardianPositionX         ;
    cmp zpGuardianLimit1            ;
    beq toggleGuardianDirection     ;
    cmp zpGuardianLimit2            ;
    beq toggleGuardianDirection     ;
    rts                             ;

; ***************************************************************************************
copyGuardianSprites
    lda #<guardianGraphics              ;
    sta readGuardianByte + 1            ; set address to read guardian graphics
    lda #>guardianGraphics              ;
    sta readGuardianByte + 2            ;

    lda #$ea                            ; }
    ldx #0                              ; }
-
    nop                                 ; }
    nop                                 ; }
    nop                                 ; }
    nop                                 ; }
    nop                                 ; } was some code nop'd out here?!
    nop                                 ; }
    inx                                 ; }
    cpx #4                              ; }
    bne -                               ; }

    ldx currentLevel                    ;
    lda guardianSetForEachLevel - 1,x   ;
    sta zpGuardianPositionX             ;

    ldx #1                              ;
-
    cpx zpGuardianPositionX             ;
    beq copyGuardiansWithAddress        ;
    lda readGuardianByte + 1            ;
    clc                                 ;
    adc #$80                            ; multiplication by repeated addition
    sta readGuardianByte + 1            ; add $80 for each X up to zpGuardianPositionX
    lda readGuardianByte + 2            ;
    adc #0                              ;
    sta readGuardianByte + 2            ;
    inx                                 ;
    jmp -                               ;

; ***************************************************************************************
copyGuardiansWithAddress
    ldx #0                              ; loop counter
-
    jsr readGuardianByte                ;
    sta softCharacterDefinitions,x      ;
    inx                                 ; copy from guardian sprites to $0c00-$0c7f
    cpx #$80                            ;
    bne -                               ;

    ldy #0                              ; loop counter
-
    lda softCharacterDefinitions,y      ;
    sty tempY                           ;
    jsr reverseBitsInByte               ;
    ldy tempY                           ; copy reflected guardians to $0c80-$0cff
    sta $0c80,y                         ;
    iny                                 ;
    cpy #$80                            ;
    bne -                               ;

    ; find guardian data for current level
    lda #<(guardianLevelData - 1)       ;
    sta readGuardianByte + 1            ; set start of guardian level data
    lda #>(guardianLevelData - 1)       ;
    sta readGuardianByte + 2            ;

    ldy #0                              ;
    ldx #0                              ;
findGuardianDataLoop
    lda readGuardianByte + 1            ; }
    clc                                 ; }
    adc #1                              ; }
    sta readGuardianByte + 1            ; } increment source address
    lda readGuardianByte + 2            ; }
    adc #0                              ; }
    sta readGuardianByte + 2            ; }
    jsr readGuardianByte                ;
    cmp #$ff                            ;
    beq checkLevelNumber                ; when we reach a 255 (a level separator byte), then branch
    jmp findGuardianDataLoop            ;

; ***************************************************************************************
checkLevelNumber
    iny                                 ;
    cpy currentLevel                    ;
    bne findGuardianDataLoop            ; if (not current level) then branch (loop back)

    ldy #0                              ;
    ldx #1                              ;
copyGuardianPositionDataLoop
    jsr readGuardianByte                ;
    jsr storeByteToD80                  ; Y coordinate
    iny                                 ;
    iny                                 ;
    jsr storeByteToD80                  ; X1 coordinate
    inx                                 ;
    dey                                 ;
    jsr readGuardianByte                ; Y coordinate
    jsr storeByteToD80                  ;
    inx                                 ;
    iny                                 ;
    iny                                 ;
    jsr readGuardianByte                ; X2 coordinate
    jsr storeByteToD80                  ;
    inx                                 ;
    jsr readGuardianByte                ;
    iny                                 ;
    cmp #$ff                            ;
    bne copyGuardianPositionDataLoop    ;
    jsr storeByteToD80                  ;
    jmp swapPagesC00andE00              ;

; ***************************************************************************************
storeByteToD80
    sta guardianPositions,y             ;
    rts                                 ;

; ***************************************************************************************
;
; Note: this only copies 255 bytes, rather than 256 bytes
;
; ***************************************************************************************
swapPagesC00andE00
    ldx #0                              ;
swapPagesLoop
    lda softCharacterDefinitions,x      ;
    tay                                 ;
    lda $0e00,x                         ;
    sta softCharacterDefinitions,x      ; swap page at $0c00 with page at $0e00
    tya                                 ;
    sta $0e00,x                         ;
    inx                                 ;
    cpx #$ff                            ;
    bne swapPagesLoop                   ; copy 255 bytes in this loop
    rts                                 ;

; ***************************************************************************************
;
; See also "reverseBits" for another copy of this routine and a smaller, faster implementation in comments
;
; ***************************************************************************************
reverseBitsInByte
    sta tempReversingByte               ;
    ldy #0                              ; loop counter
    ldx #0                              ;
reverseLoop
    lda tempReversingByte               ;
    clc                                 ;
    rol                                 ;
    sta tempReversingByte               ;
    bcs reverseBitCarrySet              ;
    txa                                 ;
    clc                                 ;
backToReversingLoop
    ror                                 ;
    tax                                 ;
    iny                                 ;
    cpy #8                              ;
    bne reverseLoop                     ;
    rts                                 ;

; ***************************************************************************************
    ; $20a5
tempReversingByte
    !byte $ea                           ;
tempY
    !byte $ea                           ;

; ***************************************************************************************
reverseBitCarrySet
    txa                             ;
    sec                             ;
    jmp backToReversingLoop         ;

; ***************************************************************************************
rememberCharacterToDraw
    !byte $ea                       ;

; ***************************************************************************************
drawIfNotOverExit
    sta rememberCharacterToDraw     ;
    lda vduTextCursorYPosition      ;
    clc                             ;
    adc #2                          ;
    cmp exitPositionY               ;
    bne testNextYPosition           ;
textXPosition
    lda vduTextCursorXPosition      ;
    cmp exitPositionX               ;
    beq moveForward                 ;
    sec                             ;
    sbc #1                          ;
    cmp exitPositionX               ;
    bne +                           ;
moveForward
    lda #9                          ; move forward
    jmp OSWRCH                      ;

testNextYPosition
    sec                             ;
    sbc #1                          ;
    cmp exitPositionY               ;
    bne +                           ;
    jmp textXPosition               ;

+
    lda rememberCharacterToDraw     ;
    jmp OSWRCH                      ;

; ***************************************************************************************
guardianColourTable
    !byte $03, $02, $01, $03        ;

    ; $20e5
    !byte $ea                       ; [UNUSED]

guardianSetForEachLevel
    ; level 1,   2,   3,   4,   5,   6,   7,  8,    9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,  20
    !byte $01, $02, $03, $04, $05, $06, $07, $08, $09, $0a, $0b, $08, $0c, $00, $0d, $0e, $0f, $09, $10, $01

; ***************************************************************************************
updateLevel19Special
    jsr updateLevel19EnergyFields       ;

    ; copy guardian info away
    ldx #0                              ; loop counter
-
    lda guardianPositions,x             ;
    sta guardianPositionsCopy,x         ;
    inx                                 ;
    cpx #5                              ;
    bne -                               ;

    lda meteorXCoordinate               ; x coordinate
    sec                                 ;
    sbc #5                              ;
    asl                                 ;
    asl                                 ;
    sta guardianPositions               ;

    lda meteorYCoordinate               ; y coordinate
    clc                                 ;
    adc #1                              ;
    sta guardianPositions + 1           ; set y coordinate

    lda #$ff                            ;
    sta guardianPositions + 4           ; only one guardian
    jsr collideWithHorizontalGuardians  ; check for collision

    ; copy guardian info back
    ldx #0                              ;
-
    lda guardianPositionsCopy,x         ;
    sta guardianPositions,x             ;
    inx                                 ;
    cpx #5                              ;
    bne -                               ;

    jsr swapMeteorSpritesWith0C00       ;
    inc meteorYCoordinate               ; meteor moves down

    lda #17                             ;
    jsr OSWRCH                          ;
    lda #3                              ; COLOUR 3
    jsr OSWRCH                          ;

    lda #31                             ;
    jsr OSWRCH                          ;
    lda meteorXCoordinate               ; TAB(meteorXCoordinate, meteorYCoordinate + 1)
    jsr OSWRCH                          ; x coordinate

    lda meteorYCoordinate               ;
    and #1                              ;
    sta meteorTailAnimationOffset       ;
    lda meteorYCoordinate               ;
    cmp #0                              ;
    bne gotoYPosition                   ;

    clc                                 ;
    adc #1                              ;
    jsr OSWRCH                          ; y coordinate 1
    jmp checkForMeteorLanding           ;


; ***************************************************************************************
gotoYPosition
    jsr OSWRCH                      ; y coordinate
    lda #charSPACE                  ;
    jsr printCharacterAndMoveBelow  ;

checkForMeteorLanding
    lda meteorYCoordinate           ;
    cmp meteorLandingY              ;
    beq meteorLanded                ;

    ; meteor still falling
meteorAnimationState1
    lda #$e0                        ;
    clc                             ;
    adc meteorTailAnimationOffset   ;
    tay                             ;
    jsr printCharacterAndMoveBelow  ; draw meteor tail
    tya                             ;
    clc                             ;
    adc #2                          ;
    jsr OSWRCH                      ; draw meteor
    jmp swapMeteorSpritesWith0C00   ;

; ***************************************************************************************
meteorLanded
    inc meteorAnimationState        ;
    dec meteorYCoordinate           ;
    lda meteorAnimationState        ;
    cmp #4                          ;
    beq eraseLandedMeteors          ;
    cmp #1                          ;
    beq meteorAnimationState1       ;
    cmp #2                          ;
    beq meteorAnimationState2       ;

    ; animation state 3
    lda #$e5                        ;
    jsr printCharacterAndMoveBelow  ;
    lda #$e7                        ;
    jsr OSWRCH                      ;
    jmp swapMeteorSpritesWith0C00   ;

; ***************************************************************************************
eraseLandedMeteors
    lda #0                          ;
    sta meteorAnimationState        ;
    lda #$ff                        ;
    sta meteorYCoordinate           ;
    lda #charSPACE                  ;
    jsr printCharacterAndMoveBelow  ;
    lda #charSPACE                  ;
    jsr OSWRCH                      ;

    ; show next meteor
    inc meteorIndex                 ;
    lda meteorIndex                 ;
    and #$0f                        ;
    tax                             ;
    lda meteorPositions,x           ;
    tay                             ;
    and #$1f                        ;
    clc                             ;
    adc #4                          ;
    sta meteorXCoordinate           ;
    tya                             ;
    and #$e0                        ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    lsr                             ;
    clc                             ;
    adc #3                          ;
    sta meteorLandingY              ;
    lda meteorXCoordinate           ;
    cmp #$19                        ;
    beq landingPoint11              ;
    cmp #$1a                        ;
    beq landingPoint11              ;
    jmp swapMeteorSpritesWith0C00   ;

; ***************************************************************************************
landingPoint11
    lda #$0b                        ;
    sta meteorLandingY              ;
    jmp swapMeteorSpritesWith0C00   ;

; ***************************************************************************************
meteorAnimationState2
    lda #$e4                        ;
    jsr printCharacterAndMoveBelow  ;
    lda #$e6                        ;
    jsr OSWRCH                      ;
    jmp swapMeteorSpritesWith0C00   ;

; ***************************************************************************************
swapMeteorSpritesWith0C00
    ldx #0                          ; loop counter
-
    lda meteorAndTailSprites,x      ;
    tay                             ;
    lda softCharacterDefinitions,x  ;
    sta meteorAndTailSprites,x      ;
    tya                             ;
    sta softCharacterDefinitions,x  ;
    inx                             ;
    cpx #$40                        ;
    bne -                           ;
    rts                             ;

; ***************************************************************************************
printCharacterAndMoveBelow
    jsr OSWRCH                      ;
    lda #$0a                        ;
    jsr OSWRCH                      ;
    lda #8                          ;
    jmp OSWRCH                      ;

; ***************************************************************************************
updateLevel19EnergyFields
    lda energyFieldTimer            ;
    and #$10                        ;
    cmp #0                          ;
    beq +                           ;

    ldx #$3f                        ;
    ldy #$f2                        ;
    jsr checkForCollisionLevel19    ;

    ldx #$49                        ;
    ldy #$f2                        ;
    jsr checkForCollisionLevel19    ;

+
    jmp animateLevel19EnergyFields  ;

; ***************************************************************************************
checkForCollisionLevel19
    stx readScreenByte + 2          ;
    sty readScreenByte + 1          ;
    ldx #0                          ;
    jsr readScreenByte              ;
    and #$80                        ; top bit set indicates collision
    cmp #0                          ;
    bne deathJumper2                ;
    ldx #7                          ;
    jsr readScreenByte              ;
    and #1                          ; bottom bit set indicates collision
    cmp #0                          ;
    bne deathJumper2                ;
    ldx #$90                        ;
    jsr readScreenByte              ;
    and #$80                        ; top bit set indicates collision
    cmp #0                          ;
    bne deathJumper2                ;
    ldx #$97                        ;
    jsr readScreenByte              ;
    and #1                          ; bottom bit set indicates collision
    cmp #0                          ;
    bne deathJumper2                ;
    rts                             ;

; ***************************************************************************************
deathJumper2
    jmp death                       ;

; ***************************************************************************************
readScreenByte
    lda $ffff,x                     ;
    rts                             ;

; ***************************************************************************************
    ; $227b
meteorLandingY
    !byte $06                       ;
meteorXCoordinate
    !byte $08                       ;
meteorYCoordinate
    !byte $ff                       ;
meteorAnimationState
    !byte $00                       ;
meteorIndex
    !byte $00                       ;

meteorPositions
    !byte $64, $1b, $28, $a9, $16, $1d, $02, $58, $65, $57, $27, $d9, $aa, $1c, $15, $63

; ***************************************************************************************
drawFooterText
    lda #$60                        ;
    sta drawFooterTextOrReturn      ; Store opcode for RTS
    jsr drawRoomName                ;
    jmp drawScoreLevelLives         ;

; ***************************************************************************************
resetLevel19Meteors
    lda #$20                        ; }
    sta drawFooterTextOrReturn      ; } store opcode for JSR
    lda #8                          ;
    sta meteorXCoordinate           ;
    lda #$ff                        ;
    sta meteorYCoordinate           ;
    lda #6                          ;
    sta meteorLandingY              ;
    lda #0                          ;
    sta meteorIndex                 ;
    lda #$f0                        ;
    sta energyFieldTimer            ;
    jmp resetVerticalSprites        ;

; ***************************************************************************************
    !byte $7c, $6b, $4c, $e8        ; [UNUSED]

meteorAndTailSprites
    !byte %........
    !byte %........
    !byte %..#...#.
    !byte %#..#...#
    !byte %.#..#.#.
    !byte %#..#...#
    !byte %.#..#.#.
    !byte %...#..#.

    !byte %........
    !byte %..#.....
    !byte %..#.#.#.
    !byte %.#..#.#.
    !byte %.#..#.#.
    !byte %.#.#...#
    !byte %..#...#.
    !byte %...#.#..

    !byte %.#..#...
    !byte %...###..
    !byte %..#.###.
    !byte %.#####.#
    !byte %.#.#.###
    !byte %.#####.#
    !byte %..##.##.
    !byte %...###..

    !byte %.#....#.
    !byte %..####..
    !byte %..##.##.
    !byte %.#.#####
    !byte %.#####.#
    !byte %.##.####
    !byte %..###.#.
    !byte %...###..

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %..#...#.
    !byte %#..#...#
    !byte %.#..#.#.

    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %........
    !byte %.#......

    !byte %#..#...#
    !byte %.#..#.#.
    !byte %...#..#.
    !byte %.#..#...
    !byte %...###..
    !byte %..#.###.
    !byte %.#####.#
    !byte %.#.#.###

    !byte %....#..#
    !byte %..#.....
    !byte %...#.#..
    !byte %.#......
    !byte %..#.#...
    !byte %......#.
    !byte %..#...#.
    !byte %.#.###.#

; ***************************************************************************************
    ; Three bytes per guardian, specifying initial position and direction:
    ;   X1, Y + top bit, X2
    ;   top bit indicates initial direction (set = left), initial bounce at X2
guardianLevelData
    ; level 1
    !byte $ff, $1a, $87, $3a
    ; level 2
    !byte $ff, $47, $03, $01, $72, $0d, $2d
    ; level 3
    !byte $ff, $3f, $03, $01, $4a, $0d, $01, $45, $83, $72
    ; level 4
    !byte $ff, $01, $8d, $26, $15, $8d, $3a
    ; level 5
    !byte $ff, $0c, $87, $2f, $2f, $03, $01
    ; level 6
    !byte $ff, $14, $88, $32, $34, $88, $52, $19, $8d, $4e, $5d, $8d, $72
    ; level 7
    !byte $ff, $38, $81, $72, $27, $08, $05, $41, $8d, $72
    ; level 8
    !byte $ff, $22, $0d, $01, $29, $ab, $3a, $45, $87, $52
    ; level 9
    !byte $ff, $31, $83, $46, $31, $aa, $46
    ; level 10
    !byte $ff, $41, $85, $52, $20, $87, $36, $0d, $8d, $66, $36, $2a, $1c
    ; level 11
    !byte $ff, $14, $8d, $4a, $38, $83, $5b, $35, $a7, $49
    ; level 12
    !byte $ff, $26, $ab, $3a, $22, $0d, $02, $5e, $86, $6e
    ; level 13
    !byte $ff, $1a, $81, $6e, $6e, $24, $1a, $62, $07, $26, $5a, $2a, $1a
    ; level 14
    !byte $ff
    ; level 15
    !byte $ff, $40, $ad, $4b
    ; level 16
    !byte $ff, $65, $a5, $72, $4a, $0d, $02, $45, $87, $5e, $02, $8a, $1e
    ; level 17
    !byte $ff, $10, $ad, $1f, $2c, $8d, $62
    ; level 18
    !byte $ff, $2e, $a3, $46, $46, $06, $2e, $2e, $aa, $46, $42, $0d, $2e
    ; level 19
    !byte $ff, $4a, $0b, $1e, $72, $0d, $5a, $1a, $0d, $02
    ; level 20
    !byte $ff, $1a, $83, $2e, $4a, $21, $30, $29, $29, $05
    !byte $ff

    ; [UNUSED]
    !byte $29, $05
    !byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff

; ***************************************************************************************
showTitleScreenMessageAndWaitForRETURN
    lda #2                          ;
    sta lives                       ;

    lda #31                         ; }
    jsr OSWRCH                      ; }
    lda #$12                        ; }
    jsr OSWRCH                      ; } TAB(18,19)
    lda #$13                        ; }
    jsr OSWRCH                      ; }

    ; print 18 spaces
    lda #charSPACE                  ;
    ldx #0                          ; loop counter
-
    jsr OSWRCH                      ;
    inx                             ;
    cpx #18                         ;
    bne -                           ;

    ; set palette to regular numbers
    ldx #0                          ;
-
    txa                             ;
    jsr setPalette                  ;
    inx                             ;
    cpx #5                          ;
    bne -                           ;

    ; set logical colour 3 to white
    lda #7                          ;
    ldx #3                          ;
    jsr setPalette                  ;

    ; delay loop
    lda #$d0                        ;
    sta $70                         ;
    tax                             ;
    tay                             ;
    sta $70                         ;   [redundant]

-
    inx                             ;
    bne -                           ;
    iny                             ;
    bne -                           ;
    stx $71                         ; reset to zero
    sty $72                         ;

    ldy #$ff                        ;
    ldx #$b6                        ;
    lda #$81                        ; wait for RETURN key
    jsr OSBYTE                      ;
    cpy #$ff                        ;
    beq startGameJumper             ; if (RETURN pressed) then branch

    ldy $72                         ;
    ldx $71                         ;
    inc $70                         ;
    bne -                           ;

    lda #0                          ;
    sta channel3Frequency           ; }
    jsr resumeMusic                 ; } demo mode
    jmp playAttractLoop             ; }

; ***************************************************************************************
startGameJumper
    jmp startGame                   ;

; ***************************************************************************************
resetVerticalSprites
    lda #$ff                        ;
    sta willyIsOnGround             ;
    jmp copyVerticalSprites         ;

; ***************************************************************************************
    !byte $00                       ; [UNUSED]

; ***************************************************************************************
creditsMessage
    !byte 31, 19, 2                 ; TAB(19,2)
    !text "SOFTWARE PROJECTS"
    !byte 31, 23, 4                 ; TAB(23,4)
    !text "Presents"
    !byte 31, 26, 9                 ; TAB(26,9)
    !text "BY"
    !byte 31, 21, 11                ; TAB(21,11)
    !text "D.J.COATHUPE"
    !byte 31, 19, 15                ; TAB(19,15)
    !text "ORIGINAL PROGRAM"
    !byte 31                        ; TAB...
creditsMessageEnd

    !byte $00                                       ; [UNUSED]

; ***************************************************************************************
;
; Later levels (9 and 11 upwards) can have up to four vertical guardians
;
; Guardian position data is packed into two bytes:
;
; <x coordinate>    x position in cells, top bit specifies initial direction, (clear = up, set = down)
; <y coordinates>   top nybble is the initial Y and also the second extent, bottom nybble is the first extent
;
; ***************************************************************************************
verticalGuardians
    !byte $00, $00, $00, $00, $00, $00, $00, $00    ; [UNUSED]
    !byte $85, $0d, $cb, $0d, $94, $0d, $d9, $0d    ; level 9
    !byte $00, $00, $00, $00, $00, $00, $00, $00    ; [UNUSED]
    !byte $83, $4d, $8c, $07, $95, $6d, $da, $0d    ; level 11
    !byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff    ; level 12
    !byte $85, $1d, $ff, $ff, $ff, $ff, $ff, $ff    ; level 13
    !byte $c1, $09, $8b, $04, $d5, $07, $ff, $ff    ; level 14
    !byte $89, $4d, $8f, $5d, $d5, $4d, $ff, $ff    ; level 15
    !byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff    ; level 16
    !byte $83, $8d, $4a, $c0, $13, $80, $db, $0c    ; level 17
    !byte $c5, $1d, $8a, $1d, $d4, $1d, $99, $1d    ; level 18
    !byte $ff, $ff, $ff, $ff, $ff, $ff, $ff, $ff    ; level 19
    !byte $82, $06, $da, $4d, $ff, $ff, $ff, $ff    ; level 20

bylineMessage
    !byte 19, 17                    ; ...(19,17)
    !text "BY MATTHEW SMITH"
    !byte 31, 19, 7                 ; TAB(19,7)
bylineMessageEnd

; ***************************************************************************************
    !byte $00, $00, $00             ; [UNUSED]

    ; $24f8
zeroScoreJumper
    !byte $00, $00, $00, $00, $00, $00, $00, $00

; ***************************************************************************************
drawFooterTextOrReturn
    jsr drawFooterText              ;

drawScoreLevelLives
    lda currentLevel                ;
    cmp #10                         ; level 10
    bne nonLevel10                  ;
    lda #$ff                        ;
    sta conveyorLength              ;
    jmp drawFixedString             ;

; ***************************************************************************************
nonLevel10
    ldy currentLevel                ;
    lda fixedText - 1,y             ;
    and #$80                        ;
    clc                             ;
    adc $71                         ;
    clc                             ;
    adc #5                          ;
    sta conveyorX                   ;

    lda $72                         ;
    clc                             ;
    adc #1                          ;
    sta conveyorY                   ;

    lda $73                         ;
    sta conveyorLength              ;

drawFixedString
    lda #31                         ;
    jsr OSWRCH                      ;
    lda #4                          ; TAB(4,19)
    jsr OSWRCH                      ;
    lda #19                         ;
    jsr OSWRCH                      ;

    ; draw fixed text below play area
    ldy #0                          ;
-
    lda fixedText,y                 ;
    and #$7f                        ;
    jsr OSWRCH                      ;
    iny                             ;
    cpy #32                         ;
    bne -                           ;
    rts                             ;

; ***************************************************************************************
updatePlayerAirAndDrawConveyor
    jsr updateAirAndCheckExit       ;
    lda currentLevel                ;
    cmp #18                         ;
    beq return10                    ;


    inc conveyorSpriteOffset        ;
    lda conveyorLength              ;
    cmp #$ff                        ;
    beq return10                    ;

    lda #17                         ; }
    jsr OSWRCH                      ; }
    lda #2                          ; } COLOUR 2
    jsr OSWRCH                      ; }

    lda conveyorX                   ;
    and #$80                        ;
    cmp #$80                        ;
    beq reverseConveyorDirection    ;

    lda conveyorSpriteOffset        ;
continueDrawingConveyors
    tax                             ;

    lda #31                         ;
    jsr OSWRCH                      ;
    lda conveyorX                   ;
    and #$7f                        ; remove top bit (direction)
    jsr OSWRCH                      ; TAB(conveyorX, conveyorY)
    lda conveyorY                   ;
    jsr OSWRCH                      ;

    ldy #0                          ;
    txa                             ;
    and #3                          ;
    clc                             ;
    adc #$eb                        ; sprite to draw for conveyor

-
    jsr OSWRCH                      ;
    iny                             ;
    cpy conveyorLength              ;
    bne -                           ;
return10
    rts                             ;

; ***************************************************************************************
reverseConveyorDirection
    lda conveyorSpriteOffset        ;
    eor #3                          ;
    jmp continueDrawingConveyors    ;

; ***************************************************************************************
conveyorX
    !byte $ea                       ;
conveyorY
    !byte $ea                       ;
conveyorLength
    !byte $ea                       ;
conveyorSpriteOffset
    !byte $ea                       ;

; The fixed text under the play area: "Score         Lives     Level"
; but with the top bit being the conveyor direction for each level (for the first 20 bytes)
fixedText
    !text $00 + 'S', $80 + 'c', $00 + 'o', $80 + 'r', $00 + 'e'
    !text $00 + ' ', $00 + $09, $80 + $09, $80 + $09, $00 + $09
    !text $00 + $09, $80 + $09, $80 + ' ', $00 + ' ', $00 + 'L'
    !text $00 + 'i', $80 + 'v', $00 + 'e', $80 + 's', $00 + ' '
    !text $09, $09, $20, $20, "Level"

; ***************************************************************************************
    jsr $3831                       ; [UNUSED]

showScoreLivesAndLevel
    lda #$ff                        ; }
    jsr addToScore                  ; } add 0 to score

    ; show lives
    lda #31                         ; }
    jsr OSWRCH                      ; }
    lda #$22                        ; } TAB(34,19)
    jsr OSWRCH                      ; }
    lda #$13                        ; }
    jsr OSWRCH                      ; }

    lda currentLevel                ; show current level
    tax                             ; [redundant]
    ldy #0                          ; counter for tens digit
    jsr print10sDigit               ; print 10s digit
    txa                             ; X is units
    tay                             ;
    jmp printY                      ; print units

; ***************************************************************************************
;
; On Entry:
;   A is the number to print
;   Y = 0
;
; ***************************************************************************************
print10sDigit
    cmp #10                         ;
    bcc printY                      ;
    iny                             ;
    sec                             ;
    sbc #10                         ;
    jmp print10sDigit               ;

; ***************************************************************************************
;
; print a single digit 0-9 in the Y register
;
; On Entry:
;   Y is the digit 0-9 to print
;
; ***************************************************************************************
printY
    tax                             ;
    tya                             ;
    clc                             ;
    adc #$30                        ;
    jmp OSWRCH                      ;

; ***************************************************************************************
    !byte $74, $68                  ; [UNUSED]

exitPositionX
    !byte $13                       ;
exitPositionY
    !byte $07                       ;

; ***************************************************************************************
unused
    lda $ffff,x                     ; UNUSED
    rts                             ; UNUSED

; ***************************************************************************************
; [unused]
    ; $2604
    lda #$80                        ; UNUSED
    sta unused + 1                  ; UNUSED
    lda #$26                        ; UNUSED
    sta unused + 2                  ; UNUSED
    lda #0                          ; UNUSED
    sta $2693                       ; UNUSED
    lda #17                         ; UNUSED
    jsr OSWRCH                      ; UNUSED
    lda #3                          ; UNUSED
    jsr OSWRCH                      ; UNUSED
    ldx #0                          ; UNUSED
-
    jsr unused                      ; UNUSED
    cmp #$20                        ; UNUSED
    bcc +                           ; UNUSED
unused5
    inx                             ; UNUSED
    cpx #0                          ; UNUSED
    bne -                           ; UNUSED
    inc unused + 2                  ; UNUSED
    jmp -                           ; UNUSED

; ***************************************************************************************
+
    inc $2693                       ; UNUSED
    lda currentLevel                ; UNUSED
    cmp $2693                       ; UNUSED
    bne unused5                     ; UNUSED
    lda #31                         ; UNUSED
    jsr OSWRCH                      ; UNUSED
    jsr unused                      ; UNUSED   TAB(level value + 4, 17)
    clc                             ; UNUSED
    adc #4                          ; UNUSED
    jsr OSWRCH                      ; UNUSED
    lda #17                         ; UNUSED
    jsr OSWRCH                      ; UNUSED

-
    inx                             ; UNUSED
    jsr unused                      ; UNUSED
    cmp #$20                        ; UNUSED
    bcc +                           ; UNUSED
    jsr OSWRCH                      ; UNUSED
    jmp -                           ; UNUSED

; ***************************************************************************************
+
    lda #$00                        ; UNUSED
    sta $2695                       ; UNUSED
    lda #$5a                        ; UNUSED
    sta $2696                       ; UNUSED
    ldy #$c0                        ; UNUSED
    lda #$b9                        ; UNUSED
    sta $2694                       ; UNUSED
    jsr $2694                       ; UNUSED
    eor #$ff                        ; UNUSED
    tax                             ; UNUSED
    lda #$99                        ; UNUSED
    sta $2694                       ; UNUSED
    txa                             ; UNUSED
    jsr $2694                       ; UNUSED
    iny                             ; UNUSED
    cpy #$c0                        ; UNUSED

    !byte $f0                       ; UNUSED

    ; $2680

; ***************************************************************************************
numbers
    !text 9, "Central Cavern"
    !text 9, "The Cold Room"
    !text 9, "The Menagerie"
    !text 3, "Abandoned Uranium Workings"
    !text 9, "Eugene's Lair"
    !text 8, "Processing Plant"
    !text 12, "The Vat"
    !text 0, "Miner Willy meets the Kong Beast"
    !text 7, "Wacky Amoebatrons"
    !text 6, "The Endorian Forest"
    !text 0, "Attack of the Mutant Telephones"
    !text 1, "Return of the Alien Kong Beast"
    !text 10, "Ore Refinery"
    !text 7, "Skylab Landing Bay"
    !text 12, "The Bank"
    !text 6, "The Sixteenth Cavern"
    !text 9, "The Warehouse"
    !text 6, "Amoebatrons' Revenge"
    !text 7, "The Meteor Storm     "        ; ... should really be the "Solar Power Generator" level
    !text 7, "The Final Barrier"
    !byte $0d                               ; terminator

; ***************************************************************************************
    !text 7, "Th"                   ; [UNUSED]

; ***************************************************************************************
levelNumberCounter
tempCounter
    !byte $ea                       ;

; ***************************************************************************************
setVerticalDisplayedCharacters
    lda #23                         ;
    jsr OSWRCH                      ; VDU 23
    lda #0                          ;
    jsr OSWRCH                      ; VDU 0
    lda #6                          ;
    jsr OSWRCH                      ; VDU 6
    txa                             ;
    jsr OSWRCH                      ; VDU X

    lda #0                          ;
    ldx #0                          ;
-
    jsr OSWRCH                      ; VDU 0
    inx                             ;
    cpx #6                          ;
    bne -                           ; loop 6 times
    rts                             ;

; ***************************************************************************************
clearScreen
    lda #0                          ;
    tax                             ; loop counter
-

    jsr setPalette                  ; set every colour black (A=0)
    inx                             ;
    cpx #4                          ;
    bne -                           ; if (not done four yet) then branch (loop back)

    lda #>screenStartAddress        ;
    sta injectAddressHigh           ;
    lda #<screenStartAddress        ;
    sta injectAddressLow            ;
    ldx #0                          ;
-

    lda #0                          ;
injectAddressLow = * + 1
injectAddressHigh = * + 2
    sta logicalScreenStart,x        ; clear screen
    inx                             ;
    beq finishedPage                ;
    jmp -                           ;

finishedPage
    inc injectAddressHigh           ;
    lda injectAddressHigh           ;
    cmp #>screenEndAddress          ;
    bcc -                           ;

    ldx #19                             ; set 19 character rows
    jmp setVerticalDisplayedCharacters  ;

level10Init
    lda #$e1                        ;
    sta levelFeature3               ;
    lda #2                          ;
    sta levelColourArray + 1        ;
    sta levelColourArray + 2        ;
    lda #3                          ;
    sta levelColourArray + 3        ;
    jmp levelInitContinued          ;

drawSwitches
    lda #31                         ; }
    jsr OSWRCH                      ; }
    lda #10                         ; }
    jsr OSWRCH                      ; } TAB(10,1)
    lda #1                          ; }
    jsr OSWRCH                      ; }

    lda #$f8                        ; VDU $f8
    jsr OSWRCH                      ;

    ; print 11 spaces
    ldx #0                          ;
    lda #$20                        ;
-
    inx                             ;
    jsr OSWRCH                      ;
    cpx #11                         ;
    bne -                           ;

    lda #$f8                        ; VDU $f8
    jsr OSWRCH                      ;
    jmp nonLevel10Init              ;

level13Init
    lda #$f5                        ;
    sta levelFeature1               ;
    lda #3                          ;
    sta levelColourArray + 1        ;
    jmp levelInitContinued          ;

; ***************************************************************************************
;
; set an entry in the palette
;
; On Entry:
;       X = logical colour to change
;       A = physical colour to use
;
; ***************************************************************************************
setPalette
    tay                             ;
    lda #19                         ;
    jsr OSWRCH                      ; VDU 19
    txa                             ;
    jsr OSWRCH                      ; VDU X
    tya                             ;
    ldy #0                          ;
-
    jsr OSWRCH                      ; VDU Y
    iny                             ;
    cpy #4                          ;
    bne -                           ; loop four times
    rts                             ;

readByteOffsetX
    lda $2c00,x                     ; read byte [high byte of address overwritten before use]
    rts                             ;

    sta currentLevel                ; [UNUSED]
initLevel
    jsr clearScreen                 ;
    lda #>levelDefinitions          ; } read data from $6c00 upwards
    sta readByteOffsetX + 2         ; }

    lda #$eb                        ;
    sta levelFeature3               ;

    lda currentLevel                ;
    cmp #10                         ;
    beq level10Init                 ;
    cmp #8                          ; }
    beq drawSwitches                ; } if (level 8 or 12) then branch (show switches)
    cmp #12                         ; }
    beq drawSwitches                ; }

nonLevel10Init
    lda #$eb                        ; }
    sta levelFeature3               ; }
    lda #3                          ; }
    sta levelColourArray + 2        ; } values for all levels except level 10
    lda #1                          ; }
    sta levelColourArray + 1        ; }
    lda #2                          ; }
    sta levelColourArray + 3        ; }

    lda currentLevel                ;
    cmp #13                         ;
    beq level13Init                 ;
    lda #$e2                        ;
    sta levelFeature1               ;

levelInitContinued
    ldx #0                          ;
    stx readByteOffsetX + 1         ;
    stx levelNumberCounter          ;

findLevelDataLoop
    jsr readByteOffsetX             ;
    inx                             ;
    cpx #0                          ;
    beq addToHighByte               ;
    cmp #$ff                        ;
    beq +                           ;
    jmp findLevelDataLoop           ;

addToHighByte
    inc readByteOffsetX + 2         ;
    jmp findLevelDataLoop           ;

+
    jsr readByteOffsetX             ;
    cmp #$ff                        ;
    bne findLevelDataLoop           ; if (not end of current level data) then branch (loop back)
    inc levelNumberCounter          ;
    lda levelNumberCounter          ; add one to level counter
    cmp currentLevel                ;
    bne findLevelDataLoop           ; if (not the level we are looking for) then branch (loop back)
    jmp foundLevelData              ;

; ***************************************************************************************
readLevelDataByte
    lda $2c00,x                     ;
    rts                             ;

; ***************************************************************************************
foundLevelData
    inx                             ; }
    stx readLevelDataByte + 1       ; } store address of start of level data
    lda readByteOffsetX + 2         ; }
    sta readLevelDataByte + 2       ; }

    ; the first two bytes of the level data contain 3 colours, stored in nybbles
    ldx #0                          ;
    jsr readLevelDataByte           ; read first byte of level data (colours)
    sta levelColours                ; store it
    inx                             ;
    jsr readLevelDataByte           ; read second byte of level data
    sta levelColours2               ; store it

    ; set palette to black
    ldx #0                          ;
    lda #0                          ;
-
    jsr setPalette                  ;
    inx                             ;
    cpx #4                          ;
    bne -                           ;

    ; next read header information (4 bytes) into $83-$86
    ldx #2                          ;
-
    jsr readLevelDataByte           ; read the next four bytes of level data
    sta $81,x                       ; store them at the level address
    inx                             ;
    cpx #6                          ;
    bne -                           ;

    ; $83 contains two sprite numbers to use, one in each nybble
    ;
    ;   top nybble is the floor sprite
    ; lower nybble is the crumble bar sprite
    ;
    lda $83                         ; top nybble contains sprite to copy
    and #$f0                        ;
    clc                             ;
    ror                             ;
    tax                             ;

    ; copy floor sprite from $0b00+X to $0c00 for 16 bytes
    ldy #0                          ;
-
    lda $0b00,x                     ;
    sta softCharacterDefinitions,y  ;
    inx                             ;
    iny                             ;
    cpy #16                         ;
    bne -                           ;

    lda $83                         ; lower nybble contains sprite to copy
    and #$0f                        ;
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    tax                             ;

    ; copy crumble bar sprite from $0b80+X to $0c10 for 8 bytes
    ldy #0                          ;
-
    lda $0b80,x                     ;
    sta $0c10,y                     ;
    iny                             ;
    inx                             ;
    cpy #8                          ;
    bne -                           ;

    ;
    ; copy crumble bar seven times into the different crumbled states:
    ;
    ;       $0c19-$0c28
    ;       $0c22-$0c30
    ;       $0c2b-$0c38
    ;       $0c34-$0c40
    ;       $0c3d-$0c48
    ;       $0c46-$0c50
    ;       $0c4f-$0c58
    ;
    lda #1                          ;
    sta tempCounter                 ;
    lda #$18                        ;
    sta storeAddressLow             ;

tempLoop
    ldx #0                          ;
    ldy tempCounter                 ; loop counter

-
    lda $0c10,x                     ;
storeAddressLow = * + 1
    sta $0c18,y                     ;
    inx                             ;
    iny                             ;
    cpy #8                          ;
    bne -                           ;

    inc tempCounter                 ;
    lda storeAddressLow             ;
    clc                             ;
    adc #8                          ;
    sta storeAddressLow             ;
    lda tempCounter                 ;
    cmp #8                          ;
    bne tempLoop                    ;

    ; ($84) bottom three bits contain the conveyor sprite to use
    ;       this also determines the side walls sprite
    ;
    ; We transform abcdefgh -> fgh00bcd, but in practice bcd = 000 so -> fgh00000
    lda $84                         ;
    and #$7f                        ;
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    tax                             ;

    ; copy conveyor sprite from $0ba0+X to $0c58 for 32 bytes
    ldy #0                          ;
-
    lda $0ba0,x                     ;
    sta $0c58,y                     ;
    inx                             ;
    iny                             ;
    cpy #$20                        ;
    bne -                           ;

    lda $85                         ;
    and #$f0                        ; get upper nybble
    clc                             ;
    ror                             ; divide by two
    tax                             ;

    ; copy side wall sprite from $0b40+X to $0c78 for 8 bytes
    ldy #0                          ;
-
    lda $0b40,x                     ;
    sta $0c78,y                     ;
    iny                             ;
    inx                             ;
    cpy #8                          ;
    bne -                           ;

    ; $85 holds the key sprite
    lda $85                         ;
    and #$0f                        ; get lower nybble
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ; multiply by eight
    tax                             ;

    ; copy key sprite from $0ab0+X to $0c80 for 8 bytes
    ldy #0                          ;
-
    lda $0ab0,x                     ;
    sta $0c80,y                     ;
    iny                             ;
    inx                             ;
    cpy #8                          ;
    bne -                           ;

    jsr getExitSprite               ;
    jmp drawLevel                   ;

getExitSprite
    ; $86 bottom 3 bits holds the exit sprite - top two bits are the type:
    ;
    ;   00 = 8x8 exit sprite repeated four times (lower 3 bits are sprite number)
    ;   10 = 8x16 exit sprite mirrored about the Y axis (lower 3 bits are sprite number)
    ;   01 = }
    ;   11 = } 16x16 exit sprite (lower 6 bits are the sprite number)
    ;
    lda $86                         ;
    and #$c0                        ; get top two bits
    clc                             ; [redundant]
    cmp #0                          ;
    beq getExit8x8                  ; if (neither bit set) then branch
    cmp #$80                        ;
    beq getExit8x16                 ; if (only top bit set) then branch

getExit16x16
    lda $86                         ;
    and #$3f                        ; get lower 6 bits
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    rol                             ; multiply by 32
    tax                             ;
    ; copy from $0900+X to $0c88 for 32 bytes
    ldy #0                          ;
-
    lda $0900,x                     ;
    sta $0c88,y                     ;
    inx                             ;
    iny                             ;
    cpy #32                         ;
    bne -                           ;
    rts                             ;

getExit8x8
    lda $86                         ;
    and #7                          ; get bottom three bits
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ; multiply by eight
    tax                             ;

    ; copy from $0980+X to $0c88 and $0c90 and $0c98 and $0ca0 for eight bytes
    ldy #0                          ;
-
    lda $0980,x                     ;
    sta $0c88,y                     ;
    sta $0c90,y                     ;
    sta $0c98,y                     ;
    sta $0ca0,y                     ;
    inx                             ;
    iny                             ;
    cpy #8                          ;
    bne -                           ;
    rts                             ;

getExit8x16
    lda #9                          ;
    sta getExitSourceByte + 2       ;
    lda $86                         ;
    and #$3f                        ; get lower 6 bits
    clc                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    rol                             ;
    clc                             ;
    adc #$98                        ;
    sta getExitSourceByte + 1       ;
    lda getExitSourceByte + 2       ;
    adc #0                          ;
    sta getExitSourceByte + 2       ; address of sprite set

    ; copy 16 bytes
    ldy #0                          ; loop counter
getExitSourceByte
    lda $0998                       ;
    sta $0c88,y                     ;
    lda getExitSourceByte + 1       ; }
    clc                             ; }
    adc #1                          ; }
    sta getExitSourceByte + 1       ; } increment source address
    lda getExitSourceByte + 2       ; }
    adc #0                          ; }
    sta getExitSourceByte + 2       ; }
    iny                             ;
    cpy #16                         ;
    bne getExitSourceByte           ;

    ; copy 8x8 sprite
    ldx #0                          ;
-
    lda $0c90,x                     ;
    sta $0c98,x                     ;
    inx                             ;
    cpx #8                          ;
    bne -                           ;

    ; reverse the left hand side of the exit to get the right hand side
    ldx #0                          ;
-
    lda $0c88,x                     ;
    stx tempX                       ;
    jsr reverseBits                 ;
    ldx tempX                       ;
    sta $0c90,x                     ;

    lda $0c98,x                     ;
    stx tempX                       ; [redundant]
    jsr reverseBits                 ;
    ldx tempX                       ;
    sta $0ca0,x                     ;
    inx                             ;
    cpx #8                          ;
    bne -                           ;
    rts                             ;

tempX
    !byte $ea                       ;

; ***************************************************************************************
;
; Reverse the order of all bits in A
;
; [ This is not the most efficient way of doing it
;   e.g. use this from https://sites.google.com/site/h2obsession/programming/6502
; reverseBits
;     sta byteToReverse               ;
;     lda #1                          ;
; -
;     lsr byteToReverse               ;
;     rol                             ;
;     bcc -                           ;
;     rts                             ;
; ]

; ***************************************************************************************
reverseBits
    sta byteToReverse               ;

    ldy #0                          ;
    ldx #0                          ;
reverseBitsLoop
    lda byteToReverse               ;
    clc                             ;
    rol                             ;
    sta byteToReverse               ;
    bcs bitSet                      ;
    txa                             ;
    clc                             ;

continueReverseBits
    ror                             ;
    tax                             ;
    iny                             ;
    cpy #8                          ;
    bne reverseBitsLoop             ;
    rts                             ;

byteToReverse
    !byte $ea                       ;

bitSet
    txa                             ;
    sec                             ;
    jmp continueReverseBits         ;

; ***************************************************************************************
drawExit
    ldx #7                          ;
    jsr readLevelDataByte           ;
    sta $70                         ;
    inx                             ; read level exit position (index 7 and 8 into level data)
    jsr readLevelDataByte           ;
    sta $71                         ;

    lda #31                         ;
    jsr OSWRCH                      ;
    lda $70                         ; TAB(exitX,exitY - 2)
    jsr OSWRCH                      ;
    lda $71                         ;
    sec                             ;
    sbc #2                          ;
    jsr OSWRCH                      ;

    ; Draw: f1,f2
    ;       f3,f4
    ldx #0                          ;
-
    lda exitMessage,x               ;
    jsr OSWRCH                      ;
    inx                             ;
    cpx #8                          ;
    bne -                           ;
    rts                             ;

exitMessage
    !byte $f1, $f2, $0a, $08, $08   ; $f1, $f2
    !byte $f3, $f4, $00             ; $f3, $f4

setRoomColours
    lda #0                          ;
    jsr OSWRCH                      ;
    jsr drawAirBar                  ;

    lda #17                         ;
    jsr OSWRCH                      ; COLOUR 2
    lda #2                          ;
    jsr OSWRCH                      ;

    jsr updatePlayerAirAndDrawConveyor  ;
    jsr drawExit                    ;

    ldx #0                          ;
    lda levelColours                ;
    and #$0f                        ;
    jsr setPalette                  ; set palette from lower nybble

    lda levelColours                ;
    and #$f0                        ;
    clc                             ;
    ror                             ;
    ror                             ;
    ror                             ;
    ror                             ;
    ldx #1                          ;
    jsr setPalette                  ; set palette from upper nybble

    lda levelColours2               ;
    and #$0f                        ;
    ldx #2                          ;
    jsr setPalette                  ; set palette from second colour byte (lower nybble)
    ldx #3                          ;
    lda #3                          ;
    jsr setPalette                  ; set palette(3) = 3
    jmp swapPagesC00andE00          ; use different character set

; ***************************************************************************************
command255IncrementFeatureIndex
    stx levelDataOffset             ;
    lda levelFeatureIndex           ;
    cmp #5                          ;
    beq setRoomColours              ;
    inc levelFeatureIndex           ;
    jmp decodeLevelData             ;

; ***************************************************************************************
command253SetType
    inx                             ;
    jsr readLevelDataByte           ; read next byte
    sta levelFeatureIndex           ; store next byte
    stx $70                         ; record incremented index
    jmp decodeLevelData             ;

; ***************************************************************************************
command254Rectangle
    inx                             ;
    ldy #0                          ; loop counter
-
    jsr readLevelDataByte           ; }
    sta $0071,y                     ; }
    inx                             ; } read four level bytes and store them in $71,$72,$73,$74
    iny                             ; }
    cpy #4                          ; }
    bne -                           ; }

    dex                             ;
    stx levelDataOffset             ;

    jsr drawRectangularFeature      ;
    jmp decodeLevelData             ;

; ***************************************************************************************
drawRectangularFeature
    jsr commandDrawHorizontalStrip      ;
    inc $72                             ;
    lda $72                             ;
    cmp $74                             ;
    bne drawRectangularFeature          ;
    rts                                 ;

; ***************************************************************************************
drawLevel
    jsr drawSideWallsAndFloor           ;
    lda #8                              ;
    sta levelDataOffset                 ;
    lda #0                              ;
    sta levelFeatureIndex               ;

decodeLevelData
    inc levelDataOffset                 ;
    ldx levelDataOffset                 ;
    jsr readLevelDataByte               ; read next byte of data
    cmp #$ff                            ;
    beq command255IncrementFeatureIndex ; if (255) then branch
    cmp #$fe                            ;
    beq command254Rectangle             ; if (254) then branch
    cmp #$fd                            ;
    beq command253SetType               ; if (253) then branch

    ldy #0                              ;
    ldx levelDataOffset                 ;
-
    jsr readLevelDataByte               ;
    sta $0071,y                         ;
    iny                                 ; store next three bytes of level data into $71, $72, $73
    inx                                 ; these are X, Y, Length of a feature
    cpy #3                              ; (y_max value is unchanged)
    bne -                               ;
    dex                                 ;
    stx levelDataOffset                 ; remember incremented level data offset

    jsr commandDrawHorizontalStrip      ;
    jmp decodeLevelData                 ;

; ***************************************************************************************
setColourAndDrawLevel7Platform
    lda levelFeatureIndex               ;
    cmp #1                              ;
    bne setColourAndDrawPlatform        ;
    lda #17                             ; }
    jsr OSWRCH                          ; } COLOUR 2
    lda #2                              ; }
    jsr OSWRCH                          ; }
    jmp drawPlatform                    ;

; ***************************************************************************************
setColourAndDrawLevel14Platform
    lda levelFeatureIndex               ;
    cmp #0                              ;
    bne setColourAndDrawPlatform        ;

    lda #17                             ;
    jsr OSWRCH                          ;
    lda #1                              ; COLOUR 1
    jsr OSWRCH                          ;

    lda #31                             ;
    jsr OSWRCH                          ;
    lda $71                             ;
    clc                                 ;
    adc #5                              ;
    jsr OSWRCH                          ; TAB($71 + 5, $72 + 1)
    lda $72                             ;
    clc                                 ;
    adc #1                              ;
    jsr OSWRCH                          ;

    lda #$e0                            ;
    jsr OSWRCH                          ;
    lda #$e1                            ;
    jsr OSWRCH                          ;

    rts                                 ;

; ***************************************************************************************
commandDrawHorizontalStrip
    lda currentLevel                    ;
    cmp #7                              ;
    beq setColourAndDrawLevel7Platform  ;
    cmp #14                             ;
    beq setColourAndDrawLevel14Platform ;

setColourAndDrawPlatform
    lda #17                             ;
    jsr OSWRCH                          ;
    ldx levelFeatureIndex               ;
    lda levelColourArray,x              ;
    jsr OSWRCH                          ; set colour

drawPlatform
    lda #31                             ;
    jsr OSWRCH                          ;
    lda $71                             ;
    clc                                 ;
    adc #5                              ;
    jsr OSWRCH                          ; TAB($71 + 5, $72 + 1)
    lda $72                             ;
    clc                                 ;
    adc #1                              ;
    jsr OSWRCH                          ;

    ldx levelFeatureIndex               ;
    lda levelFeatureArray,x             ;
    ldy #0                              ;
-
    jsr OSWRCH                          ;
    iny                                 ;
    cpy $73                             ;
    bne -                               ;
    lda levelFeatureIndex               ;
    cmp #3                              ;
    beq +                               ;
    rts                                 ;

+
    lda currentLevel                    ;
    cmp #10                             ;
    beq +                               ;
    lda #$f6                            ;
    sta levelFeature3                   ;

+
    jmp drawFooterTextOrReturn          ;

; ***************************************************************************************
; sprite numbers to draw (level specific)
levelFeatureArray
levelFeature0
    !byte $e0                           ;
levelFeature1
    !byte $e2                           ;
levelFeature2
    !byte $ef                           ;
levelFeature3
    !byte $eb                           ;
levelFeature4
    !byte $ea                           ;

    ; $2c54
; ***************************************************************************************
levelColourArray
    !byte $01, $01, $03, $02, $03

    !byte $00, $00, $00                 ; [UNUSED]

    ; $2c5c
drawSideWallsAndFloor

    ; draw left edge wall
    lda #$ff                            ; }
    sta $71                             ; }
    lda #0                              ; } from (-1, 0)
    sta $72                             ; }

    lda #1                              ; }
    sta $73                             ; } width 1
    lda #16                             ; } to (-1, 16)
    sta $74                             ; }

    lda #2                              ;
    sta levelFeatureIndex               ;
    jsr drawRectangularFeature          ; draw

    ; draw right edge wall
    lda #30                             ; }
    sta $71                             ; }
    lda #0                              ; } from (30,0)
    sta $72                             ; }
                                        ; } (width 1 still)
    lda #16                             ; }
    sta $74                             ; } to (30, 16)
    jsr drawRectangularFeature          ; draw

    ; draw floor
    lda #0                              ;
    sta levelFeatureIndex               ;
    lda #0                              ; }
    sta $71                             ; }
    lda #15                             ; } at (0,15)
    sta $72                             ; }

    lda #30                             ; }
    sta $73                             ; } 30 is end X coordinate
    jsr commandDrawHorizontalStrip      ; [use JMP commandDrawHorizontalStrip to avoid needing the next RTS]
    rts                                 ;

    !byte $0d, $03                      ; [UNUSED]

; ***************************************************************************************
; this following code (up to $2d00) is overwritten before it gets a chance to be used, by very similar code in miner4.a
; So this code is unused.
unused2
    lda $7180                           ; [UNUSED]
    rts                                 ; [UNUSED]

-
    jsr drawFooterTextOrReturn          ; [UNUSED]
    jmp +                               ; [UNUSED]

    lda #0                              ; [UNUSED]
    sta keyPositionCounter              ; [UNUSED]
    lda #$71                            ; [UNUSED]
    sta unused2 + 2                     ; [UNUSED]
    lda currentLevel                    ; [UNUSED]
    cmp #18                             ; [UNUSED]
    beq -                               ; [UNUSED]

+
    lda #0                              ; [UNUSED]
    sta decodeLevelByte                 ; [UNUSED]
    lda #$6f                            ; [UNUSED]
    sta unused2 + 1                     ; [UNUSED]

unused4
    jsr incrementLevelDataPointer       ; [UNUSED]
    jsr unused2                         ; [UNUSED]
    cmp #$ff                            ; [UNUSED]
    beq +                               ; [UNUSED]
    jmp unused4                         ; [UNUSED]

+
    inc decodeLevelByte                 ; [UNUSED]
    lda decodeLevelByte                 ; [UNUSED]
    cmp currentLevel                    ; [UNUSED]
    bne unused4                         ; [UNUSED]
    jsr incrementLevelDataPointer       ; [UNUSED]
    jsr unused2                         ; [UNUSED]
    sta keyType                         ; [UNUSED]
    lda keyType                         ; [UNUSED]
    and #$3f                            ; [UNUSED]
    sta singleItemSpriteOffset          ; [UNUSED]
    lda keyType                         ; [UNUSED]
    and #$c0                            ; [UNUSED]
    clc                                 ; [UNUSED]
    rol                                 ; [UNUSED]
    rol                                 ; [UNUSED]
    rol                                 ; [UNUSED]
    sta keyType                         ; [UNUSED]
    inc keyType                         ; [UNUSED]
    lda #$f0                            ; [UNUSED]
    sta singleItemSprite                ; [UNUSED]
    jsr setSingleItemNextType           ; [UNUSED]
    ldx #0                              ; [UNUSED]
    jmp decodeNextSingleItem            ; [UNUSED]
}

    ;$2D00
; ***************************************************************************************
start
    ; *FX 13,4 - disable vsync event
    lda #13                             ;
    ldx #4                              ;
    ldy #0                              ;
    jsr OSBYTE                          ;

    jsr swapManicMinerGraphicWithC00    ;

    ; *fx 200,3 - clear memory on BREAK
    lda #200                            ;
    ldx #3                              ;
    ldy #0                              ;
    jsr OSBYTE                          ;

    ; print message (switch to MODE 1)
    ldx #0                              ;
moreMessageLoop
    lda mode1Message,x                  ;
    cmp #$ff                            ;
    beq output8Zeroes                   ;
    jsr OSWRCH                          ;
outputMessageLoop
    inx                                 ;
    cpx #$37                            ;
    bne moreMessageLoop                 ;

    lda #31                             ;
    jsr OSWRCH                          ;
    lda #12                             ; TAB(12,3)
    jsr OSWRCH                          ;
    lda #3                              ;
    jsr OSWRCH                          ;

    ; VDU 128,129,130,...,143 (TAB and show user defined characters for 'MANIC MINER' lettering)
    ldx #$80                            ; loop counter
vduLoop
    txa                                 ;
    jsr OSWRCH                          ;
    inx                                 ;
    cpx #$90                            ;
    bne vduLoop                         ;

    ; copy 256 bytes of screen memory 8 bytes back (centring the text)
    ldx #0                              ;
-
    lda $3840,x                         ;
    sta $3838,x                         ;
    inx                                 ;
    bne -                               ;

    stx $393e                           ; store zero byte on screen
    jsr swapManicMinerGraphicWithC00    ; swap back character definitions

    ; fill in the background with RED
    lda #$b8                            ;
    sta $70                             ; screen address $35b8
    lda #$35                            ;
    sta $71                             ;

    ldx #0                              ;
loop1
    ldy #0                              ;
-
    lda ($70),y                         ;
    ora #$0f                            ; colour the background red
    sta ($70),y                         ; while leaving the foreground logo white
    iny                                 ;
    bne -                               ;
    inx                                 ;

    lda $70                             ; }
    clc                                 ; }
    adc #$80                            ; }
    sta $70                             ; } add $280 to screen address
    lda $71                             ; }
    adc #2                              ; }
    sta $71                             ; }
    cpx #7                              ;
    bne loop1                           ; if (fill not finished) then branch (loop back)
    jmp postFill

output8Zeroes
    ldy #8                              ;
    lda #0                              ;
out8loop
    jsr OSWRCH                          ;
    dey                                 ;
    bne out8loop                        ;
    jmp outputMessageLoop               ;

    ; swap $2f00-$2fff with $0c00-$0cff ('manic miner' graphics as character definitions)
swapManicMinerGraphicWithC00
    ldx #0                              ;
-
    lda manicMinerGraphic,x             ;
    tay                                 ;
    lda softCharacterDefinitions,x      ;
    sta manicMinerGraphic,x             ;
    tya                                 ;
    sta softCharacterDefinitions,x      ;
    inx                                 ;
    bne -                               ;
    rts                                 ;

postFill
    ; show 14 rows of screen
    ldx #0                              ;
-
    lda show14Rows,x                    ;
    jsr OSWRCH                          ;
    inx                                 ;
    cpx #show14RowsEnd - show14Rows     ;
    bne -                               ;

    ; output 8 zeros
    lda #0                              ;
    ldy #8                              ;
-
    jsr OSWRCH                          ;
    dey                                 ;
    bne -                               ;

    ; set text window
    ldx #0                              ;
-
    lda setTextWindow,x                 ;
    jsr OSWRCH                          ;
    inx                                 ;
    cpx #setTextWindowEnd - setTextWindow   ;
    bne -                               ;

    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;
    nop                                 ;

    ; *FX 14,4
    lda #14                             ;
    ldx #4                              ;
    ldy #0                              ;
    jsr OSBYTE                          ;

    ; *L.MINER3
    ldx #<loadMiner3                    ;
    ldy #>loadMiner3                    ;
    jsr OSCLI                           ;

    ; *L.MINER4
    ldx #<loadMiner4                    ;
    ldy #>loadMiner4                    ;
    jsr OSCLI                           ;
    jmp afterLoads                      ;

; ***************************************************************************************
    !byte $ea, $ea, $ea, $ea            ; [UNUSED]

show14Rows
    !byte $17, $00, $06, $0e            ;
show14RowsEnd

setTextWindow
    !byte 28, 12, 13, 26, 10            ; VDU 28,left,bottom,right,top
setTextWindowEnd

loadMiner3
    !text "L.MINER3",13                 ; OSCLI command to load MINER 3
loadMiner4
    !text "L.MINER4",13                 ; OSCLI command to load MINER 4

; ***************************************************************************************
afterLoads
    lda #$8c                            ;
    jsr OSWRCH                          ; VDU 140 [why?]

    ; copy ($0500-$05ff) to ($0d00-$0dff)
    ldx #0                              ;
copyMemoryLoop
    lda $0500,x                         ;
    sta $0d00,x                         ;
    ; copy ($0600-$06ff) to ($0f00-$0fff)
    lda $0600,x                         ;
    sta $0f00,x                         ;
    ; copy ($0700-$07ff) to ($1000-$10ff)
    lda $0700,x                         ;
    sta $1000,x                         ;
    inx                                 ;
    bne copyMemoryLoop                  ;
    jmp miner4EntryPoint                ;

; ***************************************************************************************
    !byte $ea, $ea, $ea, $ea            ; [UNUSED]

mode1Message
    !byte 22, 1                         ; MODE 1
    !byte 23, 0, 6, 0, $ff              ; hide display
    !byte 31, 17, 5                     ; TAB(17,5)
    !byte $90                           ; VDU 144 (user defined character - copyright)
    !text "1984"                        ;

    !byte 31, 12, 7                     ; TAB(12,7)
    !text "By D.J.Coathupe"             ;
    !byte 23,0,13,$50, $ff              ; set display address (low)
    !byte 19, 0, 4, $ff                 ; set palette blue background
    !byte 19, 2, 2, $ff                 ; set palette logical colour 2 to physical colour 2
    !byte 23, 0, 7, 30, $ff             ; move display down
    !byte 23, 1, 0, $ff                 ; cursor off

    ; [UNUSED]
    !byte $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00

    ; $2f00
; ***************************************************************************************
manicMinerGraphic
    !byte $00, $00, $00, $03, $04, $04, $04, $03
    !byte $07, $03, $06, $0c, $98, $30, $60, $c0
    !byte $8e, $9c, $bc, $ec, $cc, $0c, $0c, $1e
    !byte $00, $0e, $1b, $31, $31, $7f, $60, $f1
    !byte $00, $0e, $07, $87, $86, $c6, $c6, $ef
    !byte $00, $3d, $18, $98, $d8, $78, $38, $19
    !byte $00, $e1, $c3, $c6, $c6, $c6, $c3, $e1
    !byte $00, $f0, $18, $00, $00, $00, $18, $f0
    !byte $00, $01, $01, $00, $00, $00, $00, $00
    !byte $fe, $0f, $2d, $cc, $0c, $0c, $0c, $1e
    !byte $1e, $3c, $ec, $cc, $0c, $0c, $0c, $1e
    !byte $00, $f7, $63, $63, $63, $63, $63, $f7
    !byte $00, $1e, $8c, $cc, $6c, $3c, $1c, $8c
    !byte $00, $ff, $63, $68, $78, $68, $63, $ff
    !byte $00, $7f, $30, $30, $3f, $31, $30, $78
    !byte $00, $80, $c0, $c0, $80, $80, $c8, $70
    !byte $3c, $42, $99, $a1, $a1, $99, $42, $3c
    !byte $00, $00, $00, $00, $00, $00, $00, $00
manicMinerGraphicEnd

    ; [UNUSED]
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
    !byte $00, $00, $00, $00, $00, $00

roomNumberReached
    !byte $00

    !byte $00, $00, $00, $00, $8e, $fc, $50, $04    ; [UNUSED]

keysLeft
    !byte $00
}

; ***************************************************************************************
miner2EntryPoint
    lda #0                          ;
    sta $70                         ; reset timer counter for animating logo
    lda #0                          ;
    sta $71                         ; reset scrolling message counter

    ; *FX 200,3 - clear memory on BREAK
    lda #200                        ;
    ldx #3                          ;
    ldy #0                          ;
    jsr OSBYTE                      ;

    ; set MODE 7 and text window
    ldx #0                          ;
setModeStringLoop
    lda setModeString,x             ;
    jsr OSWRCH                      ;
    inx                             ;
    cpx #setModeStringEnd - setModeString   ;
    bne setModeStringLoop           ;

    ldx #0                          ;
copyToScreen3
    lda whiteBackgroundString,x     ;
    sta $7f23,x                     ; screen address
    inx                             ;
    cpx #whiteBackgroundStringEnd - whiteBackgroundString   ;
    bne copyToScreen3               ;

    ; turn off cursor
    lda #10                         ;
    sta $fe00                       ;
    lda #$20                        ;
    sta $fe01                       ;

    ; store original EventV address
    lda vectorEVNTV                 ;
    sta eventVLow                   ;
    lda vectorEVNTV + 1             ;
    sta eventVHigh                  ;

    ; show 'Press Space'
    ldx #0                          ;
displayStringLoop
    lda pressSpaceMessage,x         ;
    jsr OSWRCH                      ;
    inx                             ;
    cpx #pressSpaceMessageEnd - pressSpaceMessage   ;
    bne displayStringLoop           ;
    jmp fromMiner2                  ;

; ***************************************************************************************
    ; [UNUSED]
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

pressSpaceMessage
    ; $86 = cyan text
    !text "       ",$86,"Press Space"
pressSpaceMessageEnd

    ; [UNUSED]
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0

; ***************************************************************************************
afterSpace
    ; relocate code
    lda #0                          ;
    sta $78                         ;
    sta $7a                         ;
    sta $7c                         ;
    lda #$54                        ; start = $5400
    sta $79                         ;
    lda #$11                        ; dest = $1100
    sta $7b                         ;
    ldx #$1f                        ; length = $1f00
    jsr copyMem                     ; copy ($5400 to $72ff) -> ($1100, $2fff)

    lda #$4c                        ; start = $4c00
    sta $79                         ;
    lda #$05                        ; dest = $0500
    sta $7b                         ;
    ldx #$08                        ; length = $0800
    jsr copyMem                     ; copy ($4c00 to $53ff) -> ($0500, $0cff)

    jmp start                       ; call relocated code

; ***************************************************************************************
copyMem
    ldy #0                          ; inner loop counter
copyMemInner
    lda ($78),y                     ; load byte
    sta ($7a),y                     ; store byte
    iny                             ;
    bne copyMemInner                ; loop back to copy 256 bytes
    inc $79                         ; increment high byte of source
    inc $7b                         ; increment high byte of destination
    dex                             ; decrement outer loop counter
    bne copyMem                     ; if not finished then branch back
    rts                             ;

; ***************************************************************************************
    ; [UNUSED]
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    !byte 0,0,0,0,0,0,0,0,0,0
